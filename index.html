<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spatial Cognition & Sign Language Research Study</title>
  <script src="https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js"></script>
  <!-- Polyfills for older browsers -->
  <script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/url-search-params-polyfill@8.1.0/index.js"></script>
  <!-- Babel standalone for optional chaining transpilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    :root {
      --primary: #2563eb;
      --primary-light: #3b82f6;
      --primary-dark: #1d4ed8;
      --success: #059669;
      --success-light: #10b981;
      --warning: #d97706;
      --warning-light: #f59e0b;
      --info: #0891b2;
      --info-light: #06b6d4;
      --gray-50: #f9fafb;
      --gray-100: #f3f4f6;
      --gray-200: #e5e7eb;
      --gray-300: #d1d5db;
      --gray-600: #4b5563;
      --gray-700: #374151;
      --gray-800: #1f2937;
      --text-primary: #111827;
      --text-secondary: #6b7280;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: var(--gray-100);
      min-height: 100vh;
      padding: 20px;
      line-height: 1.6;
      color: var(--text-primary);
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    .header { background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary-dark) 100%); color: white; padding: 40px; text-align: center; }
    .header h1 { font-size: 32px; margin-bottom: 10px; }
    .header p { font-size: 18px; opacity: 0.95; }

    .content { padding: 40px; }

    /* Screens */
    .screen { display: none; animation: fadeIn 0.3s ease-in; }
    .screen.active { display: block; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    /* Cards / banners */
    .card { background: var(--gray-50); border-radius: 12px; padding: 30px; margin: 20px 0; border: 2px solid var(--gray-200); transition: all 0.3s; }
    .card:hover { border-color: var(--primary-light); box-shadow: 0 4px 12px rgba(37, 99, 235, 0.1); transform: translateY(-1px); }

    .info-box {
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      border-left: 4px solid;
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }
    .info-box .icon {
      font-size: 20px;
      margin-top: 2px;
      flex-shrink: 0;
    }
    .info-box.time { background: #eff6ff; border-color: var(--info); color: #1e3a8a; }
    .info-box.helpful { background: #f0fdf4; border-color: var(--success); color: #14532d; }
    .info-box.friendly-tip { background: #fef3c7; border-color: var(--warning); color: #92400e; }
    .info-box.important { background: #fef2f2; border-color: #ef4444; color: #991b1b; }

    /* Completion policy callout */
    .policy-callout {
      background: #fff8e1;
      border-left: 6px solid var(--warning);
      padding: 16px 20px;
      border-radius: 10px;
      margin: 12px 0 20px;
    }
    .policy-callout h3 { margin-bottom: 8px; font-size: 16px; letter-spacing: .3px; }
    .policy-callout ul { margin: 8px 0 0 20px; text-align: left; }

    /* Forms */
    .form-group { margin-bottom: 20px; }
    .form-group label { display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary); }
    .form-group input { width: 100%; padding: 12px; border: 2px solid var(--gray-300); border-radius: 8px; font-size: 16px; transition: border-color 0.3s; }
    .form-group input:focus { outline: none; border-color: var(--primary); }
    .form-group select { 
  width: 100%; 
  padding: 12px; 
  border: 2px solid var(--gray-300); 
  border-radius: 8px; 
  font-size: 16px; 
  transition: border-color 0.3s;
  background: white;
  cursor: pointer;
}
.form-group select:focus { 
  outline: none; 
  border-color: var(--primary); 
}
    .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
    
    /* Buttons */
    .button {
      background: var(--primary);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-height: 44px;
      text-decoration: none;
    }
    .button:hover:not(:disabled) { background: var(--primary-dark); transform: translateY(-1px); box-shadow: 0 4px 12px rgba(37,99,235,0.3); }
    .button:disabled { opacity: 0.5; cursor: not-allowed; }
    .button.secondary { background: var(--gray-100); color: var(--text-primary); border: 1px solid var(--gray-300); }
    .button.secondary:hover:not(:disabled) { background: var(--gray-200); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .button.friendly { background: var(--info); }
    .button.friendly:hover:not(:disabled) { background: var(--info-light); }
    .button.success { background: var(--success); }
    .button.success:hover:not(:disabled) { background: var(--success-light); }
    .button.danger { background: #ef4444; }
    .button.danger:hover:not(:disabled) { background: #dc2626; }
    .button.optional { background: var(--info); }
    .button.optional:hover:not(:disabled) { background: var(--info-light); }
    .button.outline { background: white; color: var(--primary); border: 1px solid var(--primary); }
    .button.outline:hover:not(:disabled) { background: var(--primary-light); color: white; }
    .button.skip { background: var(--gray-200); color: var(--text-secondary); border: 1px solid var(--gray-300); font-size: 14px; padding: 6px 12px; min-height: 32px; }
    .button.skip:hover:not(:disabled) { background: var(--gray-300); }
    .button-group { display: flex; gap: 10px; margin: 20px 0; flex-wrap: wrap; justify-content: center; }

    /* Session widget */
    .session-widget { background: linear-gradient(135deg, #2563eb20, #1d4ed820); border-radius: 10px; padding: 20px; margin-bottom: 30px; display: none; }
    .session-widget.active { display: block; }
    .session-widget h3 { color: var(--primary); margin-bottom: 15px; font-size: 18px; }
    .session-details { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
    .session-detail { background: white; padding: 10px 15px; border-radius: 8px; border-left: 3px solid var(--primary); }
    .session-detail label { font-size: 12px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; }
    .session-detail .value { font-size: 16px; font-weight: bold; color: var(--text-primary); margin-top: 3px; }

    /* Code display */
    .code-display { background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary-dark) 100%); color: white; padding: 30px; border-radius: 10px; text-align: center; margin: 20px 0; }
    .code-display .code { font-size: 36px; font-weight: bold; letter-spacing: 3px; margin: 15px 0; font-family: monospace; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }

    /* Consent grid */
    .consent-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
    .consent-card { background: white; border: 2px solid var(--gray-200); border-radius: 10px; padding: 20px; text-align: center; transition: all 0.3s; position: relative; }
    #consent1-card { background:#f9f9ff; }
    #consent2-card { background:#f9f9f4; }
    .consent-card::after { content:'‚óã'; position:absolute; top:10px; right:10px; font-size:24px; color:#bbb; }
    .consent-card.completed { border-color: var(--success); background: #f1f8f4; }
    .consent-card.completed::after { content:'‚úî'; color:var(--success); }
    .consent-card.declined { border-color: var(--warning); background: #fff9e6; }
    .consent-card.declined::after { content:'‚úñ'; color:var(--warning); }
    .consent-card .status-icon { font-size: 48px; margin-bottom: 15px; }
    .consent-card h4 { color: var(--text-primary); margin-bottom: 10px; }
    .consent-card p { color: var(--text-secondary); font-size: 14px; margin-bottom: 15px; }
    .code-note { margin-top: 8px; font-size: 14px; color: var(--text-secondary); }
    .code-note li { margin-left: 20px; list-style: disc; }
    .code-entry { margin-top: 12px; background: #f0f9ff; border: 2px dashed var(--info); padding: 15px; border-radius: 8px; }
    .code-entry input { width: 100%; padding: 12px; border: 2px solid var(--primary); border-radius: 8px; font-size: 16px; }
    .status-indicator { display: block; margin-top: 6px; color: var(--text-secondary); }
    .optional-info summary { cursor: pointer; font-weight: 600; }

    /* Tasks list */
    .task-list { list-style: none; margin: 20px 0; }
    .task-item { padding: 20px; margin: 12px 0; background: white; border-radius: 10px; border-left: 6px solid var(--gray-300); display: flex; align-items: center; justify-content: space-between; transition: all 0.3s; }
    .task-item:hover { box-shadow: 0 3px 10px rgba(0,0,0,0.1); }
    .task-item.completed { border-left-color: var(--success); background: #f1f8f4; }
    .task-item.current { border-left-color: var(--info); background: #e3f2fd; font-weight: bold; animation: pulse-blue 1.5s infinite; }
    .task-item.locked { opacity: 0.5; }
    @keyframes pulse-blue { 0%,100% { box-shadow: 0 0 0 0 rgba(33,150,243,0.4); } 50% { box-shadow: 0 0 10px 2px rgba(33,150,243,0.4); } }
    .task-info { flex: 1; }
    .task-name { font-size: 16px; color: var(--text-primary); margin-bottom: 5px; }
    .task-description { font-size: 13px; color: var(--text-secondary); }
    .task-badge { background: #eceff1; color: #444; border-radius: 20px; padding: 4px 10px; font-size: 12px; margin-left: 10px; }
    .task-status { font-size: 24px; margin-left: 20px; }

    /* Progress bar */
    .progress-bar { background: var(--gray-200); height: 30px; border-radius: 15px; overflow: hidden; margin: 20px 0; position: relative; }
    .progress-bar.sticky { position: sticky; top:0; z-index:100; }
    .progress-fill { background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary-dark) 100%); height: 100%; transition: width 0.5s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px; }
    .step-indicator { text-align: center; font-size: 14px; color: var(--text-secondary); margin-top: 8px; }
    .breadcrumbs { text-align:center; font-size:14px; color: var(--text-secondary); margin-top:4px; }

    /* Video section */
    .video-container { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin: 20px 0; }
    .video-panel { text-align: center; }
    .video-panel h3 { color: var(--text-primary); margin-bottom: 15px; }
    #video-preview, #recorded-video { width: 100%; max-width: 500px; height: 375px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); background: #000; }
    #video-preview { border: 2px solid var(--success); transform: scaleX(-1); }
    #recorded-video { border: 2px solid var(--info); }
    .recording-controls { margin-top: 20px; padding: 20px; background: var(--gray-50); border-radius: 10px; }
    .recording-status { margin: 15px 0; font-size: 18px; font-weight: bold; }
    .recording-status.ready { color: var(--text-secondary); }
    .recording-status.recording { color: #ef4444; animation: pulse 1.5s infinite; }
    .recording-status.recorded { color: var(--success); }
    @keyframes pulse { 0%,100% {opacity:1} 50% {opacity:.5} }

    /* Upload progress indicator */
    #upload-progress { margin: 15px 0; padding: 15px; background: var(--gray-100); border-radius: 8px; display: none; }
    .upload-progress-bar { background: var(--gray-200); height: 8px; border-radius: 4px; overflow: hidden; margin: 10px 0; }
    #upload-progress-fill { background: var(--primary); height: 100%; width: 0%; transition: width 0.3s; }

    /* Modals */
    .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); animation: fadeIn 0.3s; }
    .modal.active { display: flex; align-items: center; justify-content: center; }
    .modal-content { background-color: white; padding: 40px; border-radius: 15px; width: 90%; max-width: 500px; text-align: center; animation: slideUp 0.3s; }
    @keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

    /* Footer */
    .footer { background: var(--gray-50); padding: 30px; text-align: center; color: var(--text-secondary); }

    /* FAB */
    .fab { position: fixed; bottom: 30px; right: 30px; z-index: 1000; background: var(--warning); color: white; border: none; padding: 15px 25px; border-radius: 50px; font-size: 14px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3); display: none; transition: all 0.3s; }
    .fab.active { display: block; }
    .fab:hover { transform: scale(1.05); }

    /* Embed shells */
    .embed-shell { background: #0b0b0b; border: 2px solid var(--gray-300); border-radius: 12px; overflow: hidden; margin-top: 16px; }
    .fs-toolbar { display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px 12px; background:#111827; color:#e5e7eb; font-size:14px; }
    .fs-toolbar .actions { display:flex; gap:8px; }
    .embed-frame { width: 100%; height: 75vh; border: none; display: block; background: #000; }
    .embed-note { color: #6b7280; font-size: 12px; padding: 8px 12px; background: #0f172a; }
    .fs-shell:fullscreen .embed-frame { height: calc(100vh - 52px); }
    .fs-shell:-webkit-full-screen .embed-frame { height: calc(100vh - 52px); }

    /* Distraction-free fallback */
    html.df-mode, html.df-mode body { height:100%; }
    html.df-mode body { overflow:hidden; position:fixed; left:0; right:0; }
    html.df-mode .container { width:100vw; height:100vh; border-radius:0; box-shadow:none; }
    html.df-mode .header, html.df-mode .footer, html.df-mode #task-instructions { display:none !important; }
    html.df-mode .embed-frame { height: calc(100vh - 52px); }

    /* Responsive */
    @media (max-width: 768px) {
      body { padding: 10px; }
      .container { border-radius: 0; margin: 0; }
      .header { padding: 20px; }
      .header h1 { font-size: 24px; }
      .header p { font-size: 16px; }
      .content { padding: 20px; }
      .card { padding: 20px; }
      .modal-content { padding: 20px; }
      .form-row, .consent-grid, .video-container { grid-template-columns: 1fr; }
      .session-details { grid-template-columns: 1fr; }
      .button-group { flex-direction: column; }
      .button { width: 100%; }
      .embed-frame { height: 70vh; }
    }
  </style>

</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Spatial Cognition & Sign Language Research Study</h1>
      <p>Gallaudet University Research Project</p>
    </div>

    <div class="content">
      <div id="live-status" role="status" aria-live="polite" class="sr-only"></div>
      <div id="top-progress" class="progress-bar sticky"><div id="top-progress-fill" class="progress-fill" style="width:0%">0%</div></div>
      <div id="step-indicator" class="step-indicator"></div>
      <div id="breadcrumbs" class="breadcrumbs"></div>

      <!-- Session Widget -->
      <div class="session-widget" id="session-widget">
        <h3>üìä Your Session</h3>
        <div class="session-details">
          <div class="session-detail">
            <label>Resume Code</label>
            <div class="value" id="widget-code">-</div>
          </div>
          <div class="session-detail">
            <label>Progress</label>
            <div class="value" id="widget-progress">0/7</div>
          </div>
          <div class="session-detail">
            <label>Time Spent</label>
            <div class="value" id="widget-time">0 min</div>
          </div>
          <div class="session-detail">
            <label>Current Task</label>
            <div class="value" id="widget-current">-</div>
          </div>
        </div>
      </div>

      <!-- Welcome -->
      <div class="screen active" id="welcome-screen">
  <h2 style="text-align: center; margin-bottom: 24px; font-size: 28px; color: var(--text-primary);">
    Welcome! Let's Get Started
  </h2>

  <div class="info-box time">
    <div class="icon">‚è±Ô∏è</div>
    <div>
      <h4 style="margin-bottom: 8px; font-weight: 600;">About 60-90 minutes total</h4>
      <p style="margin: 0; color: inherit;">You can pause anytime and return later. Your progress saves automatically after each task.</p>
    </div>
  </div>

  <div class="info-box helpful">
    <div class="icon">üí°</div>
    <div>
      <h4 style="margin-bottom: 8px; font-weight: 600;">How it works</h4>
      <ul style="margin: 8px 0 0 0; padding-left: 16px; color: inherit;">
        <li>Get your unique resume code to save progress</li>
        <li>Complete tasks at your own pace</li>
        <li>Return anytime using your code</li>
      </ul>
    </div>
  </div>

  <div class="info-box friendly-tip">
    <div class="icon">ü§ù</div>
    <div>
      <h4 style="margin-bottom: 8px; font-weight: 600;">Need help?</h4>
      <p style="margin: 0; color: inherit;">
        Having technical issues or need accommodations?
        <strong>We're here to help you succeed!</strong>
      </p>
      <div style="margin-top: 12px;">
        <button class="button secondary" onclick="openSupportEmail()" style="font-size: 14px; padding: 8px 16px;">
          üìß Email Technical Support
        </button>
      </div>
    </div>
  </div>
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 32px;">
    <div class="card">
      <div style="text-align: center;">
        <div style="font-size: 48px; margin-bottom: 16px;">üÜï</div>
        <h3 style="margin-bottom: 12px; font-size: 20px;">New Participant</h3>
        <p style="color: var(--text-secondary); margin-bottom: 20px;">
          Start fresh and get your unique session code
        </p>
        <button class="button" onclick="showScreen('new-participant')">
          Get Started ‚Üí
        </button>
      </div>
    </div>

    <div class="card">
      <div style="text-align: center;">
        <div style="font-size: 48px; margin-bottom: 16px;">üîÑ</div>
        <h3 style="margin-bottom: 12px; font-size: 20px;">Returning Participant</h3>
        <p style="color: var(--text-secondary); margin-bottom: 20px;">
          Continue where you left off with your code
        </p>
        <button class="button secondary" onclick="showScreen('returning-participant')">
          Resume Session ‚Üí
        </button>
      </div>
    </div>
  </div>

</div>

      <!-- New Participant -->
      <div class="screen" id="new-participant">
        <h2>New Participant Registration</h2>
        <p style="color: var(--text-secondary); margin-bottom: 30px;">Create your unique session to track your progress</p>

        <div class="form-row">
          <div class="form-group">
            <label for="first-initial">First Name Initial</label>
            <input type="text" id="first-initial" maxlength="1" placeholder="J" />
          </div>
          <div class="form-group">
            <label for="last-initial">Last Name Initial</label>
            <input type="text" id="last-initial" maxlength="1" placeholder="D" />
          </div>
        </div>

        <div class="form-group">
          <label for="email">Email (optional - for reminders if you pause)</label>
          <input type="email" id="email" placeholder="your.email@example.com" />
        </div>

        <div class="form-row">
          <div class="form-group">
            <label for="hearing-status">Hearing Status</label>
            <select id="hearing-status">
              <option value="" selected disabled>Select</option>
              <option value="deaf">Deaf</option>
              <option value="hearing">Hearing</option>
            </select>
          </div>
          <div class="form-group">
            <label for="fluency">ASL Fluency</label>
            <select id="fluency">
              <option value="" selected disabled>Select</option>
              <option value="fluent">Fluent</option>
              <option value="non-fluent">Non-fluent</option>
              <option value="non-signer">Non-signer</option>
            </select>
          </div>
        </div>

        <div class="button-group">
          <button class="button primary" id="create-session-btn" onclick="createNewSession()" disabled>Create Session</button>
          <button class="button secondary" onclick="showScreen('welcome-screen')">Back</button>
        </div>
      </div>

      <!-- Returning Participant -->
      <div class="screen" id="returning-participant">
        <h2>Resume Your Session</h2>
        <p style="color: var(--text-secondary); margin-bottom: 30px;">Enter your 8-character code to continue</p>

        <div class="form-group">
          <label for="resume-code">Resume Code</label>
          <input type="text" id="resume-code" maxlength="8" placeholder="ABC12345" style="text-transform: uppercase; font-family: monospace; font-size: 24px; letter-spacing: 2px; text-align: center;" />
        </div>

        <div class="button-group">
          <button class="button primary" onclick="resumeSession()">Resume Session</button>
          <button class="button secondary" onclick="showScreen('welcome-screen')">Back</button>
        </div>
      </div>

      <!-- Session Created -->
      <div class="screen" id="session-created">
        <h2>‚úÖ Session Created Successfully!</h2>
        <div class="code-display">
          <p>Your Resume Code:</p>
          <div class="code" id="display-code">ABC12345</div>
        <button class="button optional outline" onclick="copyCode(this)">üìã Copy Code</button>
        <button class="button optional outline" onclick="copyRecoveryLink(this)">üîó Copy Recovery Link</button>
          <p style="font-size: 14px; margin-top: 15px;">Save this code to resume anytime</p>
        </div>

        <div class="info-box important">
          <strong>‚ö†Ô∏è Important: Save Your Code!</strong>
          <ul style="margin: 10px 0 0 20px; text-align: left;">
            <li>Write down or screenshot your code</li>
            <li>Use this code to continue from any device</li>
            <li>Progress saves automatically after each task</li>
          </ul>
        </div>

        <button class="button primary" onclick="proceedToEEGInfo()" style="display: block; margin: 20px auto;">
          I've Saved My Code - Continue
        </button>
      </div>
      <!-- Study Information and EEG Scheduling -->
      <div class="screen" id="eeg-info">
        <h2>About the Study</h2>
        <p>This study looks at how language relates to spatial thinking, navigation, perspective taking, and mental rotation.</p>

        <h3>How you can participate</h3>
        <p><strong>Option 1, Online now, optional EEG later</strong><br/>
        Start today with our online tasks. You can take breaks and come back as needed. If you are local and interested, we will email you to offer a 30 to 45 minute EEG lab visit when sessions resume in late September 2025.</p>
        <p><strong>Option 2, Online only</strong><br/>
        Start today with our online tasks. No in person visit is needed.</p>

        <h3>Compensation and gifts</h3>
        <ul>
          <li>Rate, $25 per hour, prorated by the minute</li>
          <li>Minimum, $25 guaranteed for the online session, even if you finish in less than 60 minutes</li>
          <li>Online time, typically 60 to 90 minutes, online pay is capped at 90 minutes for budgeting</li>
          <li>Examples, 45 min = $25, 60 min = $25, 75 min = $31.25, 90 min = $37.50</li>
          <li>EEG visit, paid separately at $25 per hour for actual time in the lab</li>
          <li>Thank you gifts, a small bison plush toy plus stickers are available only to participants who can pick them up in person at our lab. Gifts are optional to accept, while supplies last, one per participant, and not tied to your answers or performance. We are not able to mail or deliver gifts</li>
        </ul>

        <h3>Voluntary participation</h3>
        <p>Participation is voluntary. You may skip any item or stop at any time with no penalty. You will be paid for the time you take, even if you stop early. Your payment and any thank you gift do not depend on how you perform.</p>

        <h3>Questions</h3>
        <p><a href="mailto:action.brain.lab@gallaudet.edu">action.brain.lab@gallaudet.edu</a></p>

        <div class="card" style="margin-top: 32px; border: 2px solid var(--info); background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);">
          <div style="text-align: center;">
            <div style="font-size: 48px; margin-bottom: 16px;">üß†</div>
            <h3 style="margin-bottom: 12px; font-size: 22px; color: var(--primary-dark);">
              EEG Session
            </h3>
            <p style="color: var(--text-primary); margin-bottom: 16px; font-size: 16px;">
              <strong>DC/MD/VA area participants:</strong> We'd love to include you in our EEG component! EEG uses small sensors on your scalp to measure brain activity during tasks. The session takes about 30-45 minutes.
            </p>

            <div class="info-box helpful" style="text-align: left; background: rgba(255,255,255,0.7); margin: 16px 0;">
              <div class="icon">‚≠ê</div>
              <div>
                <h4 style="margin-bottom: 8px; font-weight: 600;">Why EEG matters for this research</h4>
                <ul style="margin: 8px 0 0 0; padding-left: 16px; color: inherit;">
                  <li>Captures real-time brain responses to spatial tasks</li>
                  <li>Helps us understand how deaf and hearing brains process space differently</li>
                  <li><strong>Compensation:</strong> $25 for the online portion (you'll receive the full $25 even if it takes less than an hour) and $25 for the EEG session (about $50 total), with additional pay if the EEG session runs longer than expected.</li>
                  <li>ASL or spoken English available</li>
                </ul>
              </div>
            </div>

            <div class="info-box friendly-tip" style="text-align: left; background: rgba(255,255,255,0.7); margin: 16px 0;">
              <div class="icon">üìÖ</div>
              <div>
                <h4 style="margin-bottom: 8px; font-weight: 600;">Scheduling update</h4>
                <p style="margin: 0; color: inherit;">
                  Scheduling for EEG will reopen in late September, but we will keep you updated.
                </p>
              </div>
            </div>

            <div class="button-group" style="margin-top: 20px;">
              <button class="button success" onclick="scheduleEEG()" style="font-size: 16px; padding: 14px 28px;">
                üóìÔ∏è Schedule My EEG Session
              </button>
              <button class="button secondary" onclick="expressEEGInterest()" style="font-size: 16px; padding: 14px 28px;">
                üì¨ Can't Find a Time?
              </button>
              <button class="button friendly" onclick="markEEGScheduled()">
                ‚úì I Already Scheduled
              </button>
            </div>

            <p style="margin-top: 12px; font-size: 14px; color: var(--text-secondary);">
              Not in the DC area? No problem! You can still participate in the online portion.
            </p>
          </div>
        </div>

        <div class="button-group" style="margin-top: 20px;">
          <button class="button primary" onclick="proceedToConsent()">Continue</button>
        </div>
      </div>
      <div class="screen" id="consent-screen">
  <h2> Consent Forms</h2>
<div class="info-box helpful" id="voluntary-consent-box" style="margin-top: 12px;">
  <strong>IMPORTANT: Please Read</strong>
  <ul style="margin: 8px 0 0 20px; text-align: left;">
    <li>Participation in this research study is <strong>VOLUNTARY</strong>.</li>
    <li>You can withdraw at any time without penalty.</li>
    <li>We aim to compensate all participants fairly for their time.</li>
    <li>We encourage completing all tasks for the best research data.</li>
    <li>Having technical issues or need accommodations? Email us!</li>
  </ul>
</div>

  <!-- NEW: prominent warning -->
  <div class="info-box important" style="margin: 12px 0 20px;">
    <strong>‚ö†Ô∏è IMPORTANT:</strong>
    <p style="margin-top: 8px;">
      You must actually complete these Qualtrics consent forms. Simply clicking ‚ÄúI completed this form‚Äù
      without submitting the form will <u>invalidate your participation</u>.
    </p>
  </div>

  <div class="info-box friendly-tip" role="status" style="margin-top: 12px;">
    Participation is your choice. We ask that you try every task. Your answers help our research the most when you complete all tasks. There is no judgment. Try your best. If you have trouble, email us at <a class="support-email"></a> for help instead of skipping.
  </div>

  <p style="color: var(--text-secondary); margin-bottom: 16px;">
    If you already completed these in the Qualtrics screener, you can verify with a code (optional) or affirm completion below.
  </p>

  <div class="card" id="consent-steps">
    <h3 style="margin-bottom:8px;">Steps to complete the consent forms</h3>
    <ol style="margin-left:20px; text-align:left;">
      <li>Click <strong>1. Open Form in New Tab</strong>.</li>
      <li>Fill out the form. A code will appear at the end.</li>
      <li>Copy the code, then return to this page.</li>
      <li>Click <strong>2. Enter Code from Form</strong>, paste the code, and press <strong>Verify code</strong>.</li>
      <li>If you've already done the form, choose <strong>Skip Code Entry (already completed)</strong>.</li>
    </ol>
    <p class="code-note">You can switch between tabs without losing progress.</p>
  </div>

  <div class="consent-grid">
    <!-- Consent 1 -->
    <div class="consent-card" id="consent1-card">
      <div class="status-icon">üìÑ</div>
      <h4>Research Consent</h4>
      <p>General study participation consent (required)</p>
      <ul class="code-note">
        <li>The consent form will show a code at the end.</li>
        <li>Copy that code and paste it here.</li>
        <li>You can switch between tabs to copy/paste.</li>
      </ul>
      <div class="button-group" style="justify-content:center;">
        <button class="button optional" onclick="openConsent('CONSENT1')">1. Open Form in New Tab</button>
        <button class="button friendly" onclick="toggleCodeEntry('consent1')">2. Enter Code from Form</button>
        <button class="button outline" onclick="markConsentDone('consent1')">Skip Code Entry (already completed)</button>
      </div>
      <div id="consent1-code-container" class="code-entry" style="display:none;">
        <input id="consent1-code" type="text" placeholder="Paste the code from the consent form here">
        <div class="button-group" style="justify-content:flex-start; margin-top:10px;">
          <button class="button secondary" onclick="verifyConsentCode('consent1')">Verify code</button>
        </div>
        <small id="consent1-verify-note" class="status-indicator">üîÑ Waiting for consent form code...</small>
      </div>
    </div>

    <!-- Consent 2 -->
    <div class="consent-card" id="consent2-card">
      <div class="status-icon">üé•</div>
      <h4>Video Consent</h4>
      <p>For the image description recording task (optional)</p>
      <ul class="code-note">
        <li>The consent form will show a code at the end.</li>
        <li>Copy that code and paste it here.</li>
        <li>You can switch between tabs to copy/paste.</li>
      </ul>
      <div class="button-group" style="justify-content:center;">
        <button class="button optional" onclick="openConsent('CONSENT2')">1. Open Form in New Tab</button>
        <button class="button friendly" onclick="toggleCodeEntry('consent2')">2. Enter Code from Form</button>
        <button class="button outline" onclick="markConsentDone('consent2')">Skip Code Entry (already completed)</button>
        <button class="button secondary" onclick="declineVideo()">Decline Video</button>
      </div>
      <div id="consent2-code-container" class="code-entry" style="display:none;">
        <input id="consent2-code" type="text" placeholder="Paste the code from the consent form here">
        <div class="button-group" style="justify-content:flex-start; margin-top:10px;">
          <button class="button secondary" onclick="verifyConsentCode('consent2')">Verify code</button>
        </div>
        <small id="consent2-verify-note" class="status-indicator">üîÑ Waiting for consent form code...</small>
      </div>
    </div>
  </div>

  <div class="info-box helpful" style="margin-top: 10px;">
    <strong>Prefer automatic verification?</strong>
    <p style="margin-top:6px;">
      If your Qualtrics forms redirect back here with a confirmation parameter, we‚Äôll auto-verify them.
      (You can also paste a code above.)
    </p>
  </div>

  <button class="button primary" id="continue-from-consent" onclick="proceedToTasks()" disabled
          style="display: block; margin: 20px auto;">
    Continue to Study Tasks
  </button>
</div>

      <!-- Progress -->
      <div class="screen" id="progress-screen">
        <h2>Your Study Progress</h2>
        <div class="policy-callout" id="completion-policy" role="status">
  <h3>Why every task matters</h3>
  <p>Each task measures a different skill. Missing a task makes it harder to understand the full picture. If you can, please try every task. You can stop at any time.</p>
</div>

        <div class="info-box friendly-tip" id="skipped-notice" role="status" style="display:none; margin-top:12px;"></div>

        <div class="info-box friendly-tip" id="tech-vs-intent" style="margin-top: 12px;">
  <strong>ü§ù Need help? We're here to help you succeed!</strong>
  <ul style="margin: 8px 0 0 20px; text-align: left;">
    <li>Try refreshing the page</li>
    <li>Try a different browser (Chrome/Firefox recommended)</li>
    <li><button class="button secondary" onclick="openSupportEmail()" style="font-size:14px; padding:6px 12px;">üìß Email Technical Support</button></li>
  </ul>
</div>
        
        <div class="progress-bar">
          <div class="progress-fill" id="progress-fill" style="width: 0%"><span id="progress-text">0%</span></div>
        </div>
        <ul class="task-list" id="task-list"></ul>
        <div class="button-group">
          <button class="button primary" id="continue-task-btn" onclick="continueToCurrentTask()">Continue to Current Task</button>
          <button class="button secondary" onclick="saveAndExit()">Save & Exit</button>
        </div>
      </div>

      <!-- Task Host -->
      <div class="screen" id="task-screen">
        <h2 id="task-title">Task Title</h2>
        <div class="info-box friendly-tip" id="task-encouragement" role="status" style="margin-top:12px;">
          Your effort matters. Please give this task your best try. There are no wrong answers. Partial completion is better than skipping.
        </div>
        <div id="task-instructions" style="margin: 20px 0;"></div>
        <div id="task-content"></div>
      </div>

      <!-- Recording -->
      <div class="screen" id="recording-screen">
        <h2>Image Description Task</h2>

        <div class="info-box important" id="recording-consent-check" style="display: none;">
          <strong>Video consent required</strong>
          <p>Please complete the video consent form to proceed with this task.</p>
          <div class="button-group" style="margin-top: 10px;">
            <button class="button optional" onclick="openConsent('CONSENT2')">Open Video Consent</button>
            <button class="button skip" id="skip-recording-consent-btn">Unable to complete</button>
          </div>
        </div>

        <div id="recording-content" style="display: none;">
          <div class="info-box helpful">
            <strong>Language for descriptions:</strong>
            <p>If you know ASL, please use ASL. Otherwise, spoken English is fine.</p>
          </div>

          <div class="info-box friendly-tip">
            <strong>Keep recordings short</strong>
            <p>Videos over ~60 seconds (about 30MB) may fail to upload.</p>
          </div>

          <div style="text-align: center; margin: 20px 0;">
            <span style="background: var(--info); color: white; padding: 10px 20px; border-radius: 25px; font-weight: bold;">
              Image <span id="image-number">1</span> of 2
            </span>
          </div>

          <div class="video-container">
            <div class="video-panel">
              <h3>Image to Describe</h3>
              <img id="current-image" src="about:blank" alt="Image to describe" style="width: 100%; border-radius: 10px;" />
            </div>

            <div class="video-panel">
              <h3>Your Video</h3>
              <video id="video-preview" autoplay muted playsinline style="display: none;"></video>
              <video id="recorded-video" controls playsinline style="display: none;"></video>

              <div class="recording-controls">
                <div class="recording-status ready" id="recording-status">Ready to record</div>
                <div id="recording-timer" style="font-size: 24px; color: #ef4444; margin: 10px 0; display: none;">00:00</div>

                <!-- Upload Progress Indicator -->
                <div id="upload-progress">
                  <div style="display: flex; align-items: center; gap: 10px;">
                    <div style="flex: 1;">
                      <div style="font-weight: bold; margin-bottom: 5px;">Uploading video to secure storage...</div>
                      <div class="upload-progress-bar">
                        <div id="upload-progress-fill"></div>
                      </div>
                    </div>
                    <div id="upload-status">0%</div>
                  </div>
                </div>

                <div class="button-group">
                  <button class="button danger" id="record-btn" onclick="toggleRecording()">Start Recording</button>
                  <button class="button secondary" id="rerecord-btn" onclick="reRecord()" style="display: none;">Re-record</button>
                  <button class="button success" id="save-recording-btn" onclick="saveRecording()" style="display: none;">Save & Continue</button>
                </div>
              </div>
            </div>
          </div>

          <div class="info-box helpful">
            <strong>What to describe (30‚Äì60 seconds):</strong>
            <ul style="margin: 10px 0 0 20px; text-align: left;">
              <li>Objects and people you see</li>
              <li>Where things are located</li>
              <li>What is happening in the image</li>
              <li>Spatial relationships between objects</li>
            </ul>
          </div>

          <div id="recording-error" class="info-box friendly-tip" style="display:none; margin-top: 15px;"></div>

          <div class="card" id="video-upload-fallback" style="margin-top: 15px; display:none;"></div>

          <button class="button skip" id="skip-recording-btn" style="display: block; margin: 20px auto;">Unable to complete</button>
        </div>
      </div>

      <!-- Completion -->
      <div class="screen" id="completion-screen">
        <div style="text-align: center; padding: 50px;">
          <h2 style="color: var(--success); font-size: 36px; margin-bottom: 20px;">üéâ Study Complete!</h2>
          <p style="font-size: 20px; margin: 20px 0;">Thank you for participating in our research!</p>
          <div class="code-display">
            <p>Your session code was:</p>
            <div class="code" id="final-code">ABC12345</div>
          </div>
          <p style="margin-top: 20px;">Total time: <strong id="total-time">0</strong> minutes</p>
          <div class="button-group" style="margin-top:30px;">
            <button class="button success" id="mark-complete-btn" onclick="markComplete()">I'm finished</button>
          </div>
          <p id="completion-message" style="display:none; margin-top:20px; color: var(--text-secondary);">
            ‚úÖ Your participation has been recorded. You may now close this window.
          </p>
        </div>
      </div>
    </div>

    <div class="footer">
      <p>For technical support: <a class="support-email"></a></p>
      <p style="margin-top: 10px; font-size: 14px;">Your progress is automatically saved after each task.</p>
    </div>
  </div>

  <!-- FAB -->
  <button class="fab" id="pause-fab" onclick="pauseStudy()">‚è∏Ô∏è Pause</button>

  <!-- Pause Modal -->
  <div class="modal" id="pause-modal">
    <div class="modal-content">
      <h3>Paused</h3>
      <p>Your session is paused. Resume when you're ready.</p>
      <div class="button-group">
        <button class="button" onclick="resumeStudy()">Resume</button>
        <button class="button secondary" onclick="saveAndExit()">Save & Exit</button>
      </div>
    </div>
  </div>

  <!-- Exit Modal -->
  <div class="modal" id="exit-modal">
    <div class="modal-content">
      <h3>Session Saved!</h3>
      <p>Your progress has been saved.</p>
      <div class="code-display">
        <div class="code" id="modal-code">ABC12345</div>
        <button class="button optional outline" onclick="copyCode(this)">üìã Copy Code</button>
        <button class="button optional outline" onclick="copyRecoveryLink(this)">üîó Copy Recovery Link</button>
      </div>
      <p style="font-size: 14px; color: var(--text-secondary); margin-top: 20px;">Return anytime to complete remaining tasks.</p>
      <button class="button" onclick="location.reload()">Exit Study</button>
    </div>
  </div>

  <!-- EEG Modal -->
  <div class="modal" id="eeg-modal">
    <div class="modal-content">
      <h3> Local EEG Add-On Information</h3>
      <div class="info-box helpful" style="margin: 20px 0;">
        <strong>Contact the Action Brain Lab:</strong>
        <p style="margin-top: 10px;">
          Email: <strong class="support-email"></strong>
          <button class="button optional outline" onclick="copyEmail(this)" style="margin-left: 10px;">Copy Email</button>
        </p>
      </div>

      <div style="text-align: left; background: var(--gray-50); padding: 20px; border-radius: 10px; margin: 20px 0;">
        <strong>Include in your email:</strong>
        <ul style="margin: 10px 0 0 20px;">
          <li>Your session code: <strong id="eeg-session-code">TBD</strong></li>
          <li>That you're interested in the local EEG add-on</li>
          <li>Your preferred days/times for the visit</li>
          <li>Communication preference (ASL or English)</li>
        </ul>
      </div>

      <div class="button-group">
        <button class="button" onclick="tryMailto()">Open Email Client</button>
        <button class="button secondary" onclick="closeEEGModal()">Close</button>
      </div>
    </div>
  </div>
  
<!-- Pre-Skip Modal -->
<div class="modal" id="pre-skip-modal">
  <div class="modal-content">
    <h3>Before you skip, can we help?</h3>
    <p>This task is important to the study.</p>
    <div class="button-group">
      <button class="button primary" id="pre-skip-try-btn">I will try it</button>
      <button class="button secondary" id="pre-skip-help-btn">Get help by email</button>
      <button class="button secondary" id="pre-skip-break-btn">Take a break</button>
      <button class="button skip" id="pre-skip-skip-btn">I still need to skip</button>
    </div>
  </div>
</div>

<!-- Skip Modal -->
<div class="modal" id="skip-modal">
  <div class="modal-content">
    <h3>Important: Skipping reduces research quality</h3>
    <p>When a task is skipped, we lose data that cannot be replaced. If you can, please try the task first. There are no wrong answers.</p>
    <ul style="text-align:left; margin: 12px 0 0 20px;">
      <li>The task looks hard: That is OK. Try your best.</li>
      <li>Tech problem: We can help. Email <a class="support-email"></a>.</li>
      <li>Instructions are not clear: We can explain. Email <a class="support-email"></a>.</li>
      <li>Feeling frustrated: Take a short break, then come back.</li>
    </ul>
    <div class="button-group" style="margin-top: 16px;">
      <button class="button primary" id="skip-help-btn">Get help</button>
      <button class="button secondary" id="skip-try-btn">Try it now</button>
      <button class="button secondary" id="skip-break-btn">Take a break</button>
      <button class="button skip" id="skip-confirm-btn">Unable to complete</button>
    </div>
  </div>
</div>

  <script type="text/babel" data-presets="env">
    // ----- Configuration -----
    const CONFIG = {
  SHEETS_URL: 'https://script.google.com/macros/s/AKfycbxT4jpPNG6hTDbmpeo6utlOwHLPTrxBna_YjcG0yLNI9pO5hcI7yIJcTwgesvocSYSG4A/exec',
  IMAGE_1: 'images/description1.jpg',
  IMAGE_2: 'images/description2.jpg',
  ASLCT_ACCESS_CODE: 'DVCWHNABJ',
  EEG_CALENDLY_URL: 'https://calendly.com/action-brain-lab-gallaudet/spatial-cognition-eeg-only',
  SUPPORT_EMAIL: 'action.brain.lab@gallaudet.edu',
      CLOUDINARY_CLOUD_NAME: 'dll2sorkn', 
  CLOUDINARY_UPLOAD_PRESET: 'study_videos', 
      CLOUDINARY_FOLDER: 'spatial-cognition-videos',
};
const CODE_REGEX = /^\d{6}$/; // six digits from Qualtrics code

document.querySelectorAll('.support-email').forEach(el => {
  el.textContent = CONFIG.SUPPORT_EMAIL;
  if (el.tagName === 'A') el.href = `mailto:${CONFIG.SUPPORT_EMAIL}`;
});

document.querySelectorAll('.button.skip').forEach(btn => {
  btn.title = `Please try the task first or email ${CONFIG.SUPPORT_EMAIL} for help`;
});


    // ----- Tasks -----
    const TASKS = {
  'RC':   { name:'Reading Comprehension Task', description:'Read passages and answer questions',                                type:'embed',   embedUrl:'https://melodyfschwenk.github.io/readingcomp/',              canSkip:true, estMinutes:15, requirements:'None',                                     skilled:true },
  'MRT':  { name:'Mental Rotation Task',     description:'Decide if two images are the same or not',                             type:'embed',   embedUrl:'https://melodyfschwenk.github.io/mrt/',                  canSkip:true, estMinutes:6,  requirements:'Keyboard recommended',           skilled:true },
  'ASLCT':{ name:'ASL Comprehension Test',   description:'For ASL users only',                                                 url:'https://vl2portal.gallaudet.edu/assessment/', type:'external', canSkip:true, estMinutes:15, requirements:'ASL users; stable connection', skilled:true },
  'VCN':  { name:'Virtual Campus Navigation', description:'Virtual SILC Test of Navigation (SILCton)',                         url:'http://www.virtualsilcton.com/study/753798747', type:'external', canSkip:true, estMinutes:20, requirements:'Desktop/laptop; keyboard (WASD) & mouse', skilled:true },
  'SN':   { name:'Spatial Navigation',        description:'Choose the first step from the player to the stop sign (embedded below)', type:'embed',   embedUrl:'https://melodyfschwenk.github.io/spatial-navigation-web/', canSkip:true, estMinutes:8,  requirements:'Arrow keys',                     skilled:true },
  'ID':   { name:'Image Description',        description:'Record two short videos describing images (or upload if recording is unavailable).', type:'recording', canSkip:true, estMinutes:2, requirements:'Camera & microphone or video upload' },
  'DEMO': { name:'Demographics Survey',      description:'Background information & payment',                                    url:'https://gallaudet.iad1.qualtrics.com/jfe/form/SV_8GJcoF3hkHoP8BU', type:'external', estMinutes:6, requirements:'None' }

};
    // Add this after TASKS definition
    function getStandardTaskName(taskCode) {
      const mapping = {
        'RC': 'Reading Comprehension Task',
        'MRT': 'Mental Rotation Task',
        'ASLCT': 'ASL Comprehension Test',
        'VCN': 'Virtual Campus Navigation',
        'SN': 'Spatial Navigation',
        'ID': 'Image Description',
        'DEMO': 'Demographics Survey'
      };
      return mapping[taskCode] || (TASKS[taskCode] ? TASKS[taskCode].name : undefined) || taskCode;
    }

    // ----- Consents -----
    const CONSENTS = {
      'CONSENT1': { name: 'Research Consent', url: 'https://gallaudet.iad1.qualtrics.com/jfe/form/SV_cGZEQDXQpUbGq1g' },
      'CONSENT2': { name: 'Video Consent', url: 'https://gallaudet.iad1.qualtrics.com/jfe/form/SV_5j0XhME387Kii8u' }
    };

    // ----- Task sequencing -----
    const DESKTOP_TASKS = ['RC', 'MRT', 'ASLCT', 'VCN', 'SN', 'ID'];
    const MOBILE_TASKS = ['RC', 'MRT', 'ASLCT', 'SN', 'ID'];

    function mulberry32(a) {
      return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t ^= t + Math.imul(t ^ t >>> 7, 61 | t);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function shuffleWithSeed(array, seed) {
      const rng = mulberry32(seed);
      const a = array.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function ensureDemographicsLast(sequence) {
      const filtered = (sequence || []).filter(code => code !== 'DEMO');
      filtered.push('DEMO');
      return filtered;
    }

    // Detect if mobile/tablet
    function isMobileDevice() {
      const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
      const mobileUA = /Android|webOS|iPhone|iPad|iPod|Mobile|Tablet/i.test(navigator.userAgent);
      const isSmallScreen = window.innerWidth <= 1024;
      return hasTouch && (mobileUA || isSmallScreen);
    }
function tryMailto() {
  const addr = CONFIG.SUPPORT_EMAIL;
  const subject = encodeURIComponent('[EEG Add-On] Scheduling ‚Äî Session ' + (state.sessionCode || ''));
  const body = encodeURIComponent(`Hi Action Brain Lab,

I'd like to schedule the optional EEG visit.

Preferred dates/times:
Communication preference (ASL or English):

Thanks!
Session code: ${state.sessionCode || ''}`);
  window.location.href = `mailto:${addr}?subject=${subject}&body=${body}`;
}

function copyEmail(btn) {
  const addr = CONFIG.SUPPORT_EMAIL;
  navigator.clipboard.writeText(addr).then(() => {
    if (btn) { const t = btn.textContent; btn.textContent = '‚úÖ Copied!'; setTimeout(()=>btn.textContent=t, 1500); }
  });
}

function closeEEGModal() {
  const m = document.getElementById('eeg-modal');
  if (m) m.classList.remove('active');
}
    // ----- State -----
    let state = {
  sessionCode: '',
  participantID: '',
  email: '',
  hearingStatus: '',
  fluency: '',
  sequenceIndex: -1,
  sequence: [],
  currentTaskIndex: 0,
  completedTasks: [],
  skippedTasks: [],
  startTime: null,
  totalTimeSpent: 0,
  totalActiveTime: 0,
  lastActivity: null,
  currentTaskType: '',
  externalDepart: null,
  heartbeatInterval: null,
  heartbeatMisses: 0,
  externalNotified: false,
  pauseStart: null,
  totalPausedTime: 0,
  lastPauseType: null,

  consentStatus: { consent1: false, consent2: false, videoDeclined: false },

  // ‚¨áÔ∏è ADD THIS INSIDE THE STATE OBJECT
  consentVerify: {
    consent1: { verified: false, method: null, note: '' },
    consent2: { verified: false, method: null, note: '' }
  },

  recording: {
    active: false, mediaRecorder: null, chunks: [], currentImage: 0, recordings: [],
    stream: null, currentBlob: null, isVideoMode: true
  },
  uploadQueue: [],
  processingUpload: false
};

let pendingDropboxAuthState = null;

// Reusable activity timer for tasks and session tracking
function createTimer() {
  return {
    startTime: null,
    endTime: null,
    activeTime: 0,
    lastActivity: 0,
    isPaused: false,
    pauseReason: null,
    pauseCount: 0,
    inactivityTime: 0,
    pausedTime: 0,
    pauseStart: null,
    lastTick: 0,
    intervalId: null,
    externalTime: 0,
    onInactivity: null,

    start() {
      this.startTime = Date.now();
      this.lastActivity = Date.now();
      this.lastTick = Date.now();
      this.activeTime = 0;
      this.inactivityTime = 0;
      this.pausedTime = 0;
      this.pauseCount = 0;
      this.isPaused = false;
      this.pauseStart = null;
      this.intervalId = setInterval(() => this.tick(), 1000);
    },

    tick() {
      const now = Date.now();
      if (!document.hidden && !this.isPaused) {
        const timeSinceLastActivity = now - this.lastActivity;
        const timeSinceTick = now - this.lastTick;

        if (timeSinceLastActivity > 120000) {
          this.pause('inactivity');
          if (this.onInactivity) this.onInactivity();
        } else if (timeSinceLastActivity < 5000) {
          this.activeTime += timeSinceTick;
        } else {
          this.inactivityTime += timeSinceTick;
        }
      } else if (this.isPaused && this.pauseReason === 'inactivity') {
        this.inactivityTime += now - this.lastTick;
      }
      this.lastTick = now;
    },

    recordActivity() {
      this.lastActivity = Date.now();
      if (this.isPaused && this.pauseReason === 'inactivity') this.resume();
    },

    pause(reason) {
      if (!this.isPaused) {
        this.isPaused = true;
        this.pauseReason = reason;
        this.pauseCount++;
        this.pauseStart = Date.now();
      }
    },

    resume() {
      if (this.isPaused) {
        if (this.pauseReason === 'manual' && this.pauseStart) {
          this.pausedTime += Date.now() - this.pauseStart;
        }
        this.isPaused = false;
        this.pauseReason = null;
        this.lastActivity = Date.now();
        this.lastTick = Date.now();
      }
    },

    stop() {
      clearInterval(this.intervalId);
      if (this.isPaused && this.pauseStart && this.pauseReason === 'manual') {
        this.pausedTime += Date.now() - this.pauseStart;
      }
      this.endTime = Date.now();
    },

    getSummary() {
      const elapsed = (this.endTime || Date.now()) - this.startTime;
      const active = Math.min(this.activeTime, elapsed);
      const paused = Math.min(this.pausedTime, elapsed);
      const inactive = Math.min(this.inactivityTime, elapsed);

      const total = active + paused + inactive;
      if (total > elapsed) {
        const scale = elapsed / total;
        return {
          start: new Date(this.startTime).toISOString(),
          end: new Date(this.endTime || Date.now()).toISOString(),
          elapsed,
          active: Math.round(active * scale),
          pauseCount: this.pauseCount,
          paused: Math.round(paused * scale),
          inactive: Math.round(inactive * scale),
          activity: (active / elapsed) * 100
        };
      }

      return {
        start: new Date(this.startTime).toISOString(),
        end: new Date(this.endTime || Date.now()).toISOString(),
        elapsed,
        active,
        pauseCount: this.pauseCount,
        paused,
        inactive,
        activity: elapsed > 0 ? (active / elapsed) * 100 : 0
      };
    }
  };
}

const sessionTimer = createTimer();
const taskTimer = createTimer();

function showInactivityPrompt() {
  sendToSheets({ action: 'inactivity', sessionCode: state.sessionCode, task: getStandardTaskName(state.sequence[state.currentTaskIndex] || ''), deviceType: state.isMobile ? 'mobile/tablet' : 'desktop', timestamp: new Date().toISOString() });
  if (confirm('Are you still there?')) {
    taskTimer.resume();
    taskTimer.recordActivity();
    sessionTimer.resume();
    sessionTimer.recordActivity();
  }
}
taskTimer.onInactivity = showInactivityPrompt;

function startHeartbeat(taskName) {
  if (state.heartbeatInterval) return;
  state.heartbeatMisses = 0;
  state.heartbeatInterval = setInterval(() => {
    if (state.externalDepart) {
      const away = Date.now() - state.externalDepart;
      if (away > 600000 && !state.externalNotified) {
        sendToSheets({
          action: 'external_task_stuck',
          sessionCode: state.sessionCode,
          task: taskName,
          away: Math.round(away/1000),
          timestamp: new Date().toISOString()
        });
        state.externalNotified = true;
      }
    }
    sendToSheets({
      action: 'heartbeat',
      sessionCode: state.sessionCode,
      task: taskName,
      timestamp: new Date().toISOString()
    });
  }, 30000);
}

function stopHeartbeat() {
  if (state.heartbeatInterval) {
    clearInterval(state.heartbeatInterval);
    state.heartbeatInterval = null;
    state.heartbeatMisses = 0;
    state.externalNotified = false;
  }
}

function logSessionTime(stage, summary = sessionTimer.getSummary()) {
  if (!state.sessionCode) return;
  sendToSheets({
    action: 'session_timer',
    stage,
    sessionCode: state.sessionCode,
    elapsed: Math.round(summary.elapsed / 1000),
    active: Math.round(summary.active / 1000),
    pauseCount: summary.pauseCount,
    paused: Math.round(summary.paused / 1000),
    inactive: Math.round(summary.inactive / 1000),
    activity: Math.round(summary.activity),
    startTime: summary.start,
    endTime: summary.end,
    timestamp: new Date().toISOString()
  });
}

['mousemove','mousedown','keydown','touchstart'].forEach(ev => {
  document.addEventListener(ev, (e) => {
    taskTimer.recordActivity();
    sessionTimer.recordActivity();
    sendInputEvent(ev, e);
  }, { passive: true });
});

function sendInputEvent(type, e) {
  if (!state.sessionCode) return;
  const payload = {
    action: type,
    sessionCode: state.sessionCode,
    timestamp: new Date().toISOString()
  };
  if (type === 'mousemove' || type === 'mousedown' || type === 'touchstart') {
    const point = e.touches && e.touches[0] ? e.touches[0] : e;
    payload.x = point.clientX;
    payload.y = point.clientY;
  }
  if (type === 'keydown') {
    payload.key = e.key;
  }
  sendToSheets(payload);
}

document.addEventListener('visibilitychange', () => {
  const payload = {
    sessionCode: state.sessionCode,
    task: getStandardTaskName(state.sequence[state.currentTaskIndex] || ''),
    deviceType: state.isMobile ? 'mobile/tablet' : 'desktop',
    timestamp: new Date().toISOString()
  };
  if (document.hidden) {
    taskTimer.pause('visibility');
    sessionTimer.pause('visibility');
    sendToSheets({ action: 'tab_hidden', ...payload });
  } else {
    taskTimer.resume();
    sessionTimer.resume();
    sendToSheets({ action: 'tab_visible', ...payload });
  }
});

window.addEventListener('blur', () => {
  taskTimer.pause('blur');
  sessionTimer.pause('blur');
  if (state.currentTaskType === 'external') {
    state.externalDepart = Date.now();
    sendToSheets({ action: 'task_departed', sessionCode: state.sessionCode, task: getStandardTaskName(state.sequence[state.currentTaskIndex] || ''), deviceType: state.isMobile ? 'mobile/tablet' : 'desktop', timestamp: new Date().toISOString() });
    startHeartbeat(getStandardTaskName(state.sequence[state.currentTaskIndex] || ''));
  }
});

window.addEventListener('focus', () => {
  taskTimer.resume();
  sessionTimer.resume();
  if (state.currentTaskType === 'external' && state.externalDepart) {
    const away = Date.now() - state.externalDepart;
    taskTimer.externalTime += away;
    taskTimer.lastTick = Date.now();
    sendToSheets({
      action: 'task_returned',
      sessionCode: state.sessionCode,
      task: getStandardTaskName(state.sequence[state.currentTaskIndex] || ''),
      away: Math.round(away/1000),
      deviceType: state.isMobile ? 'mobile/tablet' : 'desktop',
      timestamp: new Date().toISOString()
    });
    state.externalDepart = null;
    stopHeartbeat();
  }
});

// Handle Dropbox OAuth redirect
function handleDropboxAuth() {
  const urlParams = new URLSearchParams(window.location.hash.substring(1));
  const accessToken = urlParams.get('access_token');
  
  if (accessToken) {
    localStorage.setItem('dropbox_access_token', accessToken);
    // Clean up URL
    window.location.hash = '';
    console.log('Dropbox authorized successfully');
  }
}

async function initiateDropboxAuth(stateToStore) {
  pendingDropboxAuthState = stateToStore;
  const dbx = new Dropbox.Dropbox({
    clientId: 'nvkm67mvluiu4pf',
    fetch: fetch
  });
  const authUrl = dbx.getAuthenticationUrl('https://melodyfschwenk.github.io/spatial-cognition-study/');
  const popup = window.open(authUrl, 'dropbox_auth', 'width=600,height=700');
  if (!popup) {
    alert('Please enable pop-ups in your browser to authorize Dropbox.');
    return null;
  }
  return new Promise((resolve, reject) => {
    const checkClosed = setInterval(() => {
      try {
        if (popup.closed) {
          clearInterval(checkClosed);
          reject(new Error('Authorization cancelled'));
        }
        const currentUrl = popup.location.href;
        if (currentUrl.includes('access_token=')) {
          const token = currentUrl.split('access_token=')[1].split('&')[0];
          localStorage.setItem('dropbox_access_token', token);
          popup.close();
          clearInterval(checkClosed);
          resolve(token);
        }
      } catch (e) {
        // Cross-origin errors are expected until redirect completes
      }
    }, 1000);

    setTimeout(() => {
      clearInterval(checkClosed);
      if (!popup.closed) popup.close();
      reject(new Error('Authorization timeout'));
    }, 300000);
  });
}

// Call on page load
function init() {
  handleDropboxAuth();
  setupEventListeners();

  // Secure-context guard: disable inline recording if not https
  if (!window.isSecureContext) {
    // Hide the record button if the recording screen gets opened
    const style = document.createElement('style');
    style.textContent = `#record-btn { display: none !important; }`;
    document.head.appendChild(style);
  }

  const params = new URLSearchParams(location.search);
  checkRecoveryLink();
  if (!params.has('recover')) {
    checkSavedSession();
  }

  // Gentle mobile notice content swap
  if (isMobileDevice()) {
    const warning = document.getElementById('device-warning');
    if (warning) {
      warning.className = 'info-box friendly-tip';
      warning.innerHTML = `
  <strong>üì± Mobile or Tablet?</strong>
  <p style="margin-top: 10px;">
    Some tasks work best on a computer. You can pause now and resume later with your code.
  </p>
  <ul style="margin: 10px 0 0 20px; text-align: left;">
    <li><strong>Virtual Campus Navigation</strong> needs keyboard controls (WASD/arrow keys)</li>
    <li>Video recording requires camera & microphone permissions</li>
    <li>Chrome or Firefox recommended on desktop</li>
    <li>For the best experience, we recommend switching to a computer if possible.</li>
  </ul>
`;
    }
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

    function setupEventListeners() {
      document.getElementById('first-initial').addEventListener('input', validateInitials);
      document.getElementById('last-initial').addEventListener('input', validateInitials);
      document.getElementById('hearing-status').addEventListener('change', validateInitials);
      document.getElementById('fluency').addEventListener('change', validateInitials);
      document.getElementById('resume-code').addEventListener('input', e => { e.target.value = e.target.value.toUpperCase(); });
      bindRecordingSkips();
      enhanceUploadFallback();
      bindUploadFallback();
    }

    function validateInitials(e) {
      if (e.target.id === 'first-initial' || e.target.id === 'last-initial') {
        e.target.value = e.target.value.toUpperCase().replace(/[^A-Z]/g, '').slice(0, 1);
      }
      const first = document.getElementById('first-initial').value;
      const last = document.getElementById('last-initial').value;
      const hearing = document.getElementById('hearing-status').value;
      const fluency = document.getElementById('fluency').value;
      document.getElementById('create-session-btn').disabled = !(first && last && hearing && fluency);
    }

    // ----- Screens -----
   // === REPLACE your existing showScreen with this ===
function showScreen(screenId) {
  // Hide all screens, show target
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  const screen = document.getElementById(screenId);
  if (screen) screen.classList.add('active');

  updateProgressBar();

  const crumbs = ['Home'];
  if (screenId === 'consent-screen') crumbs.push('Consent');
  else if (screenId === 'eeg-info') crumbs.push('EEG Info');
  else if (screenId === 'progress-screen') crumbs.push('Tasks');
  else if (screenId === 'task-screen' || screenId === 'recording-screen') {
    crumbs.push('Tasks');
    const t = document.getElementById('task-title');
    if (t) crumbs.push(t.textContent.trim());
  }
  const bc = document.getElementById('breadcrumbs');
  if (bc) bc.textContent = crumbs.join(' ‚Ä∫ ');

  // Show/hide session widget + FAB
  const widget = document.getElementById('session-widget');
  const showWidget = ['progress-screen','task-screen','consent-screen','recording-screen'].includes(screenId);
  if (widget) widget.classList.toggle('active', showWidget && state.sessionCode);
  const fab = document.getElementById('pause-fab');
  if (fab) fab.classList.toggle('active', showWidget && state.sessionCode);

  // Accessibility: move focus to the screen heading and announce
  const heading = screen ? screen.querySelector('h2, h1, h3') : null;
  if (heading) {
    heading.setAttribute('tabindex', '-1');
    heading.focus({ preventScroll: false });
    // Clean up tabindex after focus so it doesn't stay in tab order
    setTimeout(() => heading.removeAttribute('tabindex'), 500);
    // Live region update
    const live = document.getElementById('live-status');
    if (live) live.textContent = `Section changed: ${heading.textContent}`;
  }
}


    // ----- Session -----
    function generateCode() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      let code = '';
      for (let i = 0; i < 8; i++) code += chars.charAt(Math.floor(Math.random() * chars.length));
      return code;
    }

    function createNewSession() {
      const first = document.getElementById('first-initial').value.trim().toUpperCase();
      const last = document.getElementById('last-initial').value.trim().toUpperCase();
      const email = document.getElementById('email').value.trim();
      const hearing = document.getElementById('hearing-status').value;
      const fluency = document.getElementById('fluency').value;
      if (!first || !last || !hearing || !fluency) { alert('Please complete all fields'); return; }

      if (isMobileDevice()) {
        const proceed = confirm(
          'You are on a phone or tablet.\n\n' +
          'A computer is preferred for the best experience, but you can continue now.\n' +
          'You can also pause and resume later on a computer using your resume code.\n\n' +
          'Continue on this device?'
        );
        if (!proceed) return;
      }

      state.sessionCode = generateCode();
      state.participantID = `${first}${last}_${Date.now().toString().slice(-4)}`;
      state.email = email;
      state.hearingStatus = hearing;
      state.fluency = fluency;

      // Choose sequence (mobile vs desktop)
      const seed = Math.abs(hashCode(state.sessionCode));
      state.sequenceIndex = seed;
      if (isMobileDevice()) {
        state.sequence = shuffleWithSeed(MOBILE_TASKS, seed);
        state.isMobile = true;
      } else {
        state.sequence = shuffleWithSeed(DESKTOP_TASKS, seed);
        state.isMobile = false;
      }
      state.sequence = ensureDemographicsLast(state.sequence);

      state.startTime = Date.now();
      state.lastActivity = new Date().toISOString();

      saveState();
      sendToSheets({
        action: 'session_created',
        sessionCode: state.sessionCode,
        participantID: state.participantID,
        email: state.email,
        hearingStatus: state.hearingStatus,
        fluency: state.fluency,
        deviceType: state.isMobile ? 'mobile/tablet' : 'desktop',
        timestamp: new Date().toISOString()
      });

      document.getElementById('display-code').textContent = state.sessionCode;
      showScreen('session-created');
    }

      async function resumeSession(codeFromLink) {
        const input = codeFromLink || document.getElementById('resume-code').value;
        const code = input.toUpperCase();
        if (code.length !== 8) { alert('Please enter your 8-character resume code'); return; }
      try {
        const res = await fetch(CONFIG.SHEETS_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain;charset=utf-8' },
          body: JSON.stringify({ action: 'get_session', sessionCode: code })
        });
        const data = await res.json();
        if (!data.success || !data.session || !data.session.state) {
          alert('Session not found. Please check your code.');
          return;
        }
        state = JSON.parse(data.session.state);
        state.sequence = ensureDemographicsLast(state.sequence);
        if (data.activity_tracking) state.activity_tracking = data.activity_tracking;
        if (data.activity_summary) state.activity_summary = data.activity_summary;
        saveState();
        updateSessionWidget();
        if (!state.consentStatus.consent1) showScreen('consent-screen'); else showProgressScreen();
        if (!sessionTimer.startTime) sessionTimer.start();
      } catch (err) {
        console.error(err);
        alert('Error loading session');
      }
    }

    // === REPLACE the body of checkSavedSession with this ===
function checkSavedSession() {
  try {
    if (state.sessionCode) return;
    const recentCode = localStorage.getItem('recent_session');
    if (!recentCode) return;

    const saved = localStorage.getItem(`study_${recentCode}`);
    if (!saved) return;

    const data = JSON.parse(saved);
    const daysSince = (Date.now() - new Date(data.lastActivity).getTime()) / (1000*60*60*24);
    if (daysSince < 30) {
      // Delay so it doesn‚Äôt clash with initial UI
      setTimeout(() => {
        if (confirm(`Welcome back! Resume session ${recentCode}?`)) {
          state = data;
          state.sequence = ensureDemographicsLast(state.sequence);
          saveState();
          updateSessionWidget();
          showProgressScreen();
        }
      }, 700); // ~0.7s feels smooth with your animations
    }
  } catch (e) {
    console.warn('Could not check saved session', e);
  }
}

function checkRecoveryLink() {
  try {
    const params = new URLSearchParams(location.search);
    const token = params.get('recover');
    if (!token) return;
    const code = atob(token);
    if (code && code.length === 8) {
      resumeSession(code);
    }
    try {
      const cleanURL = location.origin + location.pathname;
      window.history.replaceState({}, '', cleanURL);
    } catch (e) {}
  } catch (e) {
    console.warn('Invalid recovery link', e);
  }
}


    function saveState() {
      try {
        if (!state || !state.sessionCode) {
          console.warn('Invalid state, not saving');
          return;
        }
        state.lastActivity = new Date().toISOString();
        localStorage.setItem(`study_${state.sessionCode}`, JSON.stringify(state));
        localStorage.setItem('recent_session', state.sessionCode);
        sendToSheets({ action: 'save_state', sessionCode: state.sessionCode, state });
      } catch (e) { console.warn('Could not save state', e); }
    }
    function proceedToEEGInfo() {
      showScreen('eeg-info');
    }

    // ----- Consent -----
    function proceedToConsent() {
      if (!sessionTimer.startTime) sessionTimer.start();
      showScreen('consent-screen');
      updateConsentDisplay();
    }
function openConsent(type) {
  const consent = CONSENTS[type];
  if (consent) {
    window.open(consent.url, '_blank', 'noopener');
    sendToSheets({ action: 'consent_opened', sessionCode: state.sessionCode, type, timestamp: new Date().toISOString() });
  }
}
function toggleCodeEntry(type) {
  const container = document.getElementById(`${type}-code-container`);
  const note = document.getElementById(`${type}-verify-note`);
  if (!container) return;
  const show = container.style.display === 'none' || container.style.display === '';
  container.style.display = show ? 'block' : 'none';
  if (show && note) {
    note.textContent = 'üîÑ Waiting for consent form code...';
    note.style.color = 'var(--text-secondary)';
  }
}
   function markConsentDone(type) {
  // Safety interlock: explicit warning + typed phrase
  const niceName = (type === 'consent1') ? 'Research Consent' : 'Video Consent';
  const ok = confirm(
    `Did you actually complete and submit the ${niceName} form on Qualtrics?\n\n` +
    `Clicking ‚ÄúOK‚Äù without completing the form will disqualify your participation.`
  );
  if (!ok) return;

  const phrase = prompt(
    `To confirm, type exactly: I COMPLETED THE CONSENT\n\n` +
    `This helps prevent accidental or invalid confirmation.`
  );

  if (!phrase || phrase.trim().toUpperCase() !== 'I COMPLETED THE CONSENT') {
    alert('Not confirmed. Please complete the form first.');
    return;
  }

  // Mark the consent as completed (same as before)
  if (type === 'consent1') {
    state.consentStatus.consent1 = true;
  } else if (type === 'consent2') {
    state.consentStatus.consent2 = true;
  }
  saveState(); updateConsentDisplay();

  // Log a stricter audit trail
  sendToSheets({
    action: 'consent_affirmed',
    sessionCode: state.sessionCode,
    type,
    method: 'typed-affirmation',
    timestamp: new Date().toISOString()
  });
  logSessionTime(type);
}
function verifyConsentCode(type) {
  const inputId = type === 'consent1' ? 'consent1-code' : 'consent2-code';
  const noteId  = type === 'consent1' ? 'consent1-verify-note' : 'consent2-verify-note';

  const el = document.getElementById(inputId);
  const noteEl = document.getElementById(noteId);
  const code = ((el && el.value) || '').trim();

  // Enforce 6 digits only
  if (!CODE_REGEX.test(code)) {
    alert('Enter the 6-digit code shown at the end of the Qualtrics form.');
    if (el) el.focus();
    return;
  }

  // Mark this consent complete & verified
  if (type === 'consent1') state.consentStatus.consent1 = true;
  if (type === 'consent2') state.consentStatus.consent2 = true;

  state.consentVerify[type] = { verified: true, method: 'code', note: '6-digit' };
  saveState();
  updateConsentDisplay();

  if (noteEl) {
    noteEl.textContent = '‚úÖ Code verified!';
    noteEl.style.color = '#1b5e20';
  }

  // Log (store only the 6-digit suffix; no PII)
  sendToSheets({
    action: 'consent_verified',
    sessionCode: state.sessionCode || 'none',
    type,
    method: 'code',
    codeSuffix: code,           // already 6 digits
    timestamp: new Date().toISOString()
  });
}

function autoVerifyConsentsFromURL() {
  try {
    const p = new URLSearchParams(location.search);
    // Support: ?c1=1&c2=1 or ?consent1=done etc. You can set these in Qualtrics "End of Survey" redirect.
    const c1 = p.get('c1') || p.get('consent1');
    const c2 = p.get('c2') || p.get('consent2');
    const rid1 = p.get('rid1') || p.get('rid'); // optionally pass ResponseID
    const rid2 = p.get('rid2');

    if (c1 && String(c1).toLowerCase() !== '0') {
      state.consentStatus.consent1 = true;
      state.consentVerify.consent1 = { verified: true, method: 'url-param', note: rid1 ? `RID ‚Ä¶${String(rid1).slice(-6)}` : '' };
      sendToSheets({
        action: 'consent_verified',
        sessionCode: state.sessionCode || 'none',
        type: 'consent1',
        method: 'url-param',
        ridSuffix: rid1 ? String(rid1).slice(-6) : '',
        timestamp: new Date().toISOString()
      });
    }

    if (c2 && String(c2).toLowerCase() !== '0') {
      state.consentStatus.consent2 = true;
      state.consentVerify.consent2 = { verified: true, method: 'url-param', note: rid2 ? `RID ‚Ä¶${String(rid2).slice(-6)}` : '' };
      sendToSheets({
        action: 'consent_verified',
        sessionCode: state.sessionCode || 'none',
        type: 'consent2',
        method: 'url-param',
        ridSuffix: rid2 ? String(rid2).slice(-6) : '',
        timestamp: new Date().toISOString()
      });
    }

    if (c1 || c2) {
      saveState(); updateConsentDisplay();
      // Optional: clean query so it doesn't re-trigger on refresh
      try {
        const cleanURL = location.origin + location.pathname;
        window.history.replaceState({}, '', cleanURL);
      } catch (e) {}
    }
  } catch (e) {
    console.warn('Auto-verify failed', e);
  }
}

// Call it during init:
document.addEventListener('DOMContentLoaded', () => {
  // ... your existing init
  autoVerifyConsentsFromURL(); // <‚Äî add this line
});

    function declineVideo() {
      if (confirm('Decline video consent? You can still participate in other tasks.')) {
        state.consentStatus.videoDeclined = true;
        state.consentStatus.consent2 = true;
        document.getElementById('consent2-card').classList.add('declined');
        document.querySelector('#consent2-card .status-icon').textContent = '‚ö†Ô∏è';
        saveState(); updateConsentDisplay();
        sendToSheets({ action: 'video_declined', sessionCode: state.sessionCode, timestamp: new Date().toISOString() });
        logSessionTime('consent2_declined');
        updateSessionWidget();
        updateProgressBar();
      }
    }
    function updateConsentDisplay() {
  const c1 = state.consentStatus.consent1;
  const c2 = state.consentStatus.consent2 || state.consentStatus.videoDeclined;

  // Buttons state
  document.getElementById('continue-from-consent').disabled = !(c1 && c2);

  // Card styles + badges
  const card1 = document.getElementById('consent1-card');
  const card2 = document.getElementById('consent2-card');

  if (c1) {
    card1.classList.remove('declined');
    card1.classList.add('completed');
    card1.querySelector('.status-icon').textContent = '‚úÖ';

    const note = document.getElementById('consent1-verify-note');
    if (state.consentVerify.consent1.verified) {
      if (note) { note.textContent = '‚úÖ Code verified!'; note.style.color = '#1b5e20'; }
    } else {
      if (note) { note.textContent = 'Affirmed without code'; note.style.color = '#856404'; }
    }
  }

  if (state.consentStatus.videoDeclined) {
    card2.classList.remove('completed');
    card2.classList.add('declined');
    card2.querySelector('.status-icon').textContent = '‚ö†Ô∏è';
  } else if (state.consentStatus.consent2) {
    card2.classList.remove('declined');
    card2.classList.add('completed');
    card2.querySelector('.status-icon').textContent = '‚úÖ';

    const note = document.getElementById('consent2-verify-note');
    if (state.consentVerify.consent2.verified) {
      if (note) { note.textContent = '‚úÖ Code verified!'; note.style.color = '#1b5e20'; }
    } else if (note) {
      note.textContent = state.consentStatus.consent2 ? 'Affirmed without code' : '';
      note.style.color = '#856404';
    }
  }
}

    function proceedToTasks() {
      if (!state.consentStatus.consent1) { alert('Please complete the research consent form'); return; }
      showProgressScreen();
    }

    // ----- Progress -----
    function showProgressScreen() { updateTaskList(); updateProgressBar(); updateSessionWidget(); updateSkippedNotice(); showScreen('progress-screen'); }
    function updateSkippedNotice() {
      const box = document.getElementById('skipped-notice');
      if (!box) return;
      const count = state.skippedTasks.length;
      if (count > 0) {
        box.style.display = 'block';
        box.textContent = `You have skipped ${count} task${count>1?'s':''}. Each task gives unique data. If you can, go back and try them. Even partial answers help. There is no judgment.`;
      } else {
        box.style.display = 'none';
      }
    }
    function updateTaskList() {
      const list = document.getElementById('task-list');
      list.innerHTML = '';
      state.sequence.forEach((taskCode, index) => {
        const task = TASKS[taskCode];
        const li = document.createElement('li');
        li.className = 'task-item';
        const isCompleted = state.completedTasks.includes(taskCode);
        const isCurrent = index === state.currentTaskIndex && !isCompleted;
        if (isCompleted) li.classList.add('completed');
        else if (isCurrent) li.classList.add('current');
        else li.classList.add('locked');
        li.innerHTML = `
          <div class="task-info">
            <div class="task-name">${task.name}<span class="task-badge">${task.estMinutes}m</span></div>
            <div class="task-description">${task.description}</div>
          </div>
          <div class="task-status">${isCompleted ? '‚úÖ' : (isCurrent ? '‚ñ∂Ô∏è' : 'üîí')}</div>
        `;
        list.appendChild(li);
      });
    }
    function getTaskCounts() {
      const isRequired = code => !(code === 'ID' && state.consentStatus.videoDeclined);
      return {
        total: state.sequence.filter(isRequired).length,
        completed: state.completedTasks.filter(isRequired).length
      };
    }
    function updateProgressBar() {
      const { total, completed } = getTaskCounts();
      if (!total) return;
      const progress = (completed / total) * 100;
      const pct = `${Math.round(progress)}%`;
      const fill = document.getElementById('progress-fill');
      const topFill = document.getElementById('top-progress-fill');
      if (fill) { fill.style.width = `${progress}%`; document.getElementById('progress-text').textContent = pct; }
      if (topFill) { topFill.style.width = `${progress}%`; topFill.textContent = pct; }
      const step = document.getElementById('step-indicator');
      if (step) step.textContent = `Step ${Math.min(completed + 1, total)} of ${total}`;
    }
    function updateSessionWidget() {
      if (!state.sessionCode) return;
      const { total, completed } = getTaskCounts();
      document.getElementById('widget-code').textContent = state.sessionCode + (state.isMobile ? ' (Mobile)' : '');
      document.getElementById('widget-progress').textContent = `${completed}/${total}`;
      document.getElementById('widget-time').textContent = `${Math.round(state.totalTimeSpent / 60000)} min`;
      const currentTask = state.sequence[state.currentTaskIndex];
      document.getElementById('widget-current').textContent = currentTask ? TASKS[currentTask].name : 'Complete';
    }

    // ----- Task flow -----
    function continueToCurrentTask() {
      if (state.currentTaskIndex >= state.sequence.length) { showCompletionScreen(); return; }
      startTask(state.sequence[state.currentTaskIndex]);
    }
    function startTask(taskCode) {
      const task = TASKS[taskCode];
      if (!task) return;

  if (!state.taskData) state.taskData = {};
  state.taskData[taskCode] = { startTime: Date.now() };
      state.currentTaskType = task.type;
      taskTimer.start();

      if (task.type === 'recording') showRecordingTask();
      else if (task.type === 'embed') showEmbeddedTask(taskCode);
      else showExternalTask(taskCode);

      const startISO = new Date().toISOString();
      sendToSheets({ action: 'task_started', sessionCode: state.sessionCode, task: getStandardTaskName(taskCode), deviceType: state.isMobile ? 'mobile/tablet' : 'desktop', timestamp: startISO, startTime: startISO });
    }

    // ----- Distraction-free fallback -----
    function enterDistractionFree() {
      document.documentElement.classList.add('df-mode');
      document.body.dataset.scrollY = window.scrollY;
      document.body.style.top = `-${window.scrollY}px`;
    }
    function exitDistractionFree() {
      document.documentElement.classList.remove('df-mode');
      const y = parseInt(document.body.dataset.scrollY || '0', 10);
      document.body.style.top = '';
      window.scrollTo(0, y);
    }

    // PostMessage completion hook
    window.addEventListener('message', (ev) => {
      const allowedOrigin = 'https://melodyfschwenk.github.io';
      if (ev.origin !== allowedOrigin) return;
      const data = ev.data || {};
      if (data.type === 'task-complete' && data.taskCode && TASKS[data.taskCode]) {
        completeTask(data.taskCode);
      }
    });

    // ----- Embedded tasks -----
    function showEmbeddedTask(taskCode) {
      const task = TASKS[taskCode];
      const url  = task.embedUrl;
      const iframeId = `embed-${taskCode.toLowerCase()}`;

      let extra = '';
      if (taskCode === 'SN') {
        extra = `
          <div class="info-box helpful" style="margin-top:10px;">
            <strong>What you'll do</strong>
            <p style="margin-top:6px;">Press <em>one</em> arrow key for the <em>first</em> step from the gray player to the red stop sign.</p>
          </div>`;
      } else if (taskCode === 'MRT') {
        extra = `
          <div class="info-box friendly-tip" style="margin-top:10px;">
            <strong>Heads up:</strong>
            <p style="margin-top:6px;">Takes about <strong>5‚Äì6 minutes</strong>. Work steadily from start to finish.</p>
          </div>`;
      }

      document.getElementById('task-title').textContent = task.name;
      const requiredText = (taskCode === 'ID' && state.consentStatus.videoDeclined)
  ? 'This task is optional for you (video consent declined).'
  : 'This task is required for study completion.';
const eta = (TASKS[taskCode] && TASKS[taskCode].estMinutes) ? `${TASKS[taskCode].estMinutes} minutes` : 'a few minutes';
const reqs = (TASKS[taskCode] && TASKS[taskCode].requirements) || '‚Äî';

      document.getElementById('task-instructions').innerHTML = `
  <div class="info-box friendly-tip" style="margin-bottom:10px;">
    <strong> Ready to Start ${task.name}?</strong>
    <ul style="margin:8px 0 0 20px; text-align:left;">
      <li>${requiredText}</li>
      <li>Having problems? Email us instead of skipping</li>
      <li>Estimated time: <strong>${eta}</strong></li>
      <li>Requirements/tips: <em>${reqs}</em></li>
    </ul>
  </div>
  <p>${task.description}</p>
  ${extra}
  <details style="margin-top:10px;"><summary style="cursor:pointer;">More info / troubleshooting</summary>
    <ul style="margin:8px 0 0 20px; text-align:left;">
      <li>If the game doesn't respond, click inside it once to give it keyboard focus.</li>
      <li>If fullscreen doesn't work on your device, we'll switch to a distraction-free view.</li>
    </ul>
  </details>
`;


      const content = document.getElementById('task-content');
      content.innerHTML = `
  <div class="card" id="prestart">
    <p>When you click <strong>Continue</strong>, the task will open in fullscreen. When you're finished, click <em>I'm finished ‚Äî Continue</em>.</p>
    <div class="button-group" style="margin-top:12px;">
      <button class="button" id="start-embed">Continue</button>
      <button class="button outline" type="button" onclick="openSupportEmail('${taskCode}')">Report Technical Issue Instead</button>
      ${task.canSkip ? `<button class="button skip" onclick="showSkipDialog('${taskCode}')" title="Please try the task first or email ${CONFIG.SUPPORT_EMAIL} for help">Unable to complete</button>` : ''}
    </div>
  </div>

  <div class="embed-shell fs-shell" id="fs-shell" style="display:none;">
    <div class="fs-toolbar" id="fs-toolbar">
      <div>${task.name}</div>
      <div class="actions">
        <button class="button success" id="finish-btn" disabled>I'm finished ‚Äî Continue</button>
        <button class="button secondary" id="exit-btn">Exit fullscreen</button>
      </div>
    </div>
    <iframe id="${iframeId}" class="embed-frame" src="${url}" allow="fullscreen; gamepad; xr-spatial-tracking" allowfullscreen></iframe>
    <div class="embed-note">Tip: click once inside the game to give it keyboard focus.</div>
  </div>
`;

      showScreen('task-screen');

      const fsShell = document.getElementById('fs-shell');
      const finishBtn = document.getElementById('finish-btn');
      const exitBtn = document.getElementById('exit-btn');
      const prestart = document.getElementById('prestart');
      const iframe = document.getElementById(iframeId);
      iframe.addEventListener('focus', () => taskTimer.recordActivity());

      const enableFinish = () => { finishBtn.disabled = false; };

      async function goFullscreen() {
        prestart.style.display = 'none';
        fsShell.style.display = 'block';

        setTimeout(() => { try { iframe.focus(); } catch(e) {} }, 50);

        try {
          if (fsShell.requestFullscreen) { await fsShell.requestFullscreen({ navigationUI: 'hide' }).catch(() => {}); }
          else if (fsShell.webkitRequestFullscreen) { fsShell.webkitRequestFullscreen(); }
          setTimeout(() => {
            const inFS = document.fullscreenElement || document.webkitFullscreenElement;
            if (!inFS) enterDistractionFree();
          }, 250);
        } catch (e) { enterDistractionFree(); }

        setTimeout(enableFinish, 6000);
      }

      function leaveFullscreenModes() {
        if (document.fullscreenElement) document.exitFullscreen().catch(()=>{});
        if (document.webkitFullscreenElement && document.webkitExitFullscreen) document.webkitExitFullscreen();
        exitDistractionFree();
      }

      document.getElementById('start-embed').onclick = goFullscreen;
      finishBtn.onclick = () => { leaveFullscreenModes(); completeTask(taskCode); };
      exitBtn.onclick = () => { leaveFullscreenModes(); fsShell.scrollIntoView({ behavior: 'smooth', block: 'start' }); enableFinish(); };

      const loadTimeout = setTimeout(() => {
        const note = document.createElement('div');
        note.className = 'embed-note';
        note.textContent = 'Still loading‚Ä¶ if nothing appears soon, try exiting fullscreen and re-entering.';
        fsShell.appendChild(note);
      }, 7000);
      iframe.addEventListener('load', () => clearTimeout(loadTimeout), { once:true });

      document.addEventListener('keydown', function escHandler(ev) {
        if (ev.key === 'Escape') {
          setTimeout(leaveFullscreenModes, 0);
          document.removeEventListener('keydown', escHandler);
        }
      });
    }

    // ----- External tasks -----
    
    // === REPLACE your existing showExternalTask with this ===
function showExternalTask(taskCode) {
  const task = TASKS[taskCode];
  let extra = '';

  const requiredText = (taskCode === 'ID' && state.consentStatus.videoDeclined)
    ? 'This task is OPTIONAL for you (video consent declined).'
    : 'This task is required for study completion.';
  const eta  = (TASKS[taskCode] && TASKS[taskCode].estMinutes) ? `${TASKS[taskCode].estMinutes} minutes` : 'a few minutes';
  const reqs = (TASKS[taskCode] && TASKS[taskCode].requirements) || '‚Äî';

  if (taskCode === 'ASLCT') {
    const ASLCT_CODE = CONFIG.ASLCT_ACCESS_CODE;
    extra = `
      <div class="info-box helpful" style="margin-top: 10px;">
        <strong>ASLCT Access Code</strong>
        <p style="margin-top: 6px;">
          On the login page, enter access code:
          <span class="code" style="font-size:22px; background:#fff; color:#333; padding:4px 8px; border-radius:6px; display:inline-block;">${ASLCT_CODE}</span>
        </p>
        <button class="button outline" onclick="navigator.clipboard.writeText('${ASLCT_CODE}').then(()=>{ this.textContent='‚úÖ Copied!'; setTimeout(()=>this.textContent='Copy Access Code',1500); })">Copy Access Code</button>
      </div>
      <div class="info-box helpful" style="margin-top: 10px;">
        <strong>Instructions:</strong>
        <ol style="margin: 10px 0 0 20px; text-align: left;">
          <li>Click "Open Task".</li>
          <li>On the ASLCT portal, paste the access code <em>${ASLCT_CODE}</em> and follow the prompts.</li>
          <li>Return here when finished and click "Mark Complete".</li>
        </ol>
      </div>
      <div style="margin-top: 10px; text-align: left;">
        <p>If you encounter any problems with the ASLCT, please describe them below and click Send.</p>
        <textarea id="aslct-issue-text" style="width: 100%; height: 80px; margin-top: 6px;"></textarea>
        <button class="button secondary" style="margin-top: 10px;" onclick="submitASLCTIssue()">Send</button>
      </div>`;
  } else if (taskCode === 'VCN') {
    extra = `
      <div class="info-box helpful" style="margin-top: 10px;">
        <strong>Virtual SILC Test of Navigation (SILCton) ‚Äî What you'll do</strong>
        <p style="margin-top: 6px;">Learn a small virtual campus (Learning phase), then answer quick questions (Test phase).</p>
        <ul style="margin: 10px 0 0 20px; text-align: left;">
          <li><strong>Controls:</strong> Move with WASD/arrow keys; look around with the mouse.</li>
          <li>Desktop/laptop recommended (Chrome/Firefox). Keep this page open.</li>
        </ul>
      </div>`;
  }

  document.getElementById('task-title').textContent = task.name;
  document.getElementById('task-instructions').innerHTML = `
    <div class="info-box friendly-tip" style="margin-bottom:10px;">
      <strong>‚ö†Ô∏è Ready to Start ${task.name}?</strong>
      <ul style="margin:8px 0 0 20px; text-align:left;">
        <li>${requiredText}</li>
        <li>Having problems? Email us instead of skipping</li>
        <li>Estimated time: <strong>${eta}</strong></li>
        <li>Requirements/tips: <em>${reqs}</em></li>
      </ul>
    </div>
    <p>${task.description}</p>
    ${extra}
    <div class="info-box helpful" style="margin-top: 10px;">
      <strong>Instructions:</strong>
      <ol style="margin: 10px 0 0 20px; text-align: left;">
        <li>Click "Open Task" to launch in a new tab.</li>
        <li>Complete the task as instructed.</li>
        <li>Return to this tab when finished.</li>
        <li>Click "Mark Complete" to continue.</li>
      </ol>
    </div>
  `;

  const content = document.getElementById('task-content');
  content.innerHTML = `
    <div class="button-group">
      <a class="button" href="${task.url}" target="_blank" rel="noopener"
         aria-label="Open Task (opens in new tab)"
         onclick="sendToSheets({ action: 'task_opened', sessionCode: state.sessionCode || 'none', timestamp: new Date().toISOString(), userAgent: navigator.userAgent, deviceType: state.isMobile ? 'mobile/tablet' : 'desktop' });">
         Open Task
      </a>
      <button class="button success" onclick="completeTask('${taskCode}')">Mark Complete</button>
      <button class="button outline" onclick="openSupportEmail('${taskCode}')">Report Technical Issue Instead</button>
    </div>
  `;
  if (task.canSkip) {
    content.innerHTML += `
      <button class="button skip" onclick="showSkipDialog('${taskCode}')" style="display: block; margin: 20px auto;" title="Please try the task first or email ${CONFIG.SUPPORT_EMAIL} for help">
        ${taskCode === 'ASLCT' ? 'Unable to complete - I do not know ASL' : 'Unable to complete'}
      </button>
    `;
  }
  showScreen('task-screen');
}

function openExternalTask(taskCode) {
  const task = TASKS[taskCode];
  if (!task || !task.url) return;
  window.open(task.url, '_blank', 'noopener');
}

    // ----- Recording task -----
    function showRecordingTask() {
      state.recording.currentImage = 0;
      state.recording.recordings = [];
      state.recording.currentBlob = null;
      if (!state.consentStatus.consent2 || state.consentStatus.videoDeclined) {
        document.getElementById('recording-consent-check').style.display = 'block';
        document.getElementById('recording-content').style.display = 'none';
      } else {
        document.getElementById('recording-consent-check').style.display = 'none';
        document.getElementById('recording-content').style.display = 'block';
        updateRecordingImage();
      }
      // NEW: if page not secure, skip recorder UI and show upload UI
if (!window.isSecureContext) {
  document.getElementById('recording-consent-check').style.display = 'none';
  document.getElementById('recording-content').style.display = 'block';
  document.getElementById('video-upload-fallback').style.display = 'block';
  const status = document.getElementById('recording-status');
  status.textContent = 'Recording disabled (requires https). Please use the upload option below.';
  status.className = 'recording-status warning';
}

      showScreen('recording-screen');
    }

    function revokeRecordedURL() {
      const recorded = document.getElementById('recorded-video');
      if (recorded && recorded.src) {
        try { URL.revokeObjectURL(recorded.src); } catch(e) {}
        recorded.removeAttribute('src');
        if (recorded.load) recorded.load();
      }
    }

    function updateRecordingImage() {
      const imageNum = state.recording.currentImage + 1;
      document.getElementById('image-number').textContent = imageNum;
      document.getElementById('current-image').src = imageNum === 1 ? CONFIG.IMAGE_1 : CONFIG.IMAGE_2;
      
      const preview = document.getElementById('video-preview');
      const recorded = document.getElementById('recorded-video');
      preview.style.display = 'none';
      recorded.style.display = 'none';
      
      // Clean up previous recording blob URL
      revokeRecordedURL();
      state.recording.currentBlob = null;
      
      // Reset UI elements
      document.getElementById('record-btn').style.display = 'inline-block';
      document.getElementById('rerecord-btn').style.display = 'none';
      document.getElementById('save-recording-btn').style.display = 'none';
      
      const status = document.getElementById('recording-status');
      status.textContent = 'Ready to record';
      status.className = 'recording-status ready';
      
      // Clear any previous errors
      document.getElementById('recording-error').style.display = 'none';
      document.getElementById('video-upload-fallback').style.display = 'none';
      document.getElementById('upload-progress').style.display = 'none';
      
      // Clear file input
      const fileInput = document.getElementById('video-file-input');
      if (fileInput) fileInput.value = '';
      
      const uploadBtn = document.getElementById('upload-save-btn');
      if (uploadBtn) {
        uploadBtn.style.display = 'none';
        uploadBtn.textContent = 'Use this upload';
      }

      // Add recording instructions with size warning
      const recordingInstructions = document.createElement('div');
      recordingInstructions.className = 'info-box important';
      recordingInstructions.id = 'recording-size-warning';
      recordingInstructions.innerHTML = `
  <strong>üìπ Recording Guidelines</strong>
  <ul style="margin: 8px 0 0 20px; text-align: left;">
    <li><strong>Duration:</strong> Keep recordings between 30-60 seconds</li>
    <li><strong>File size:</strong> Recordings over 45 seconds may fail to upload</li>
    <li><strong>Language:</strong> Use ASL if you know it, otherwise spoken English</li>
    <li><strong>Can't record?</strong> Use the "Upload a Recording" option below</li>
  </ul>
`;

      // Insert before recording controls
      const recordingContent = document.getElementById('recording-content');
      const recordingControls = document.querySelector('.recording-controls');
      if (recordingContent && recordingControls && !document.getElementById('recording-size-warning')) {
        recordingContent.insertBefore(recordingInstructions, recordingControls);
      }

      const requiredTextRec = (state.consentStatus.videoDeclined)
  ? 'This task is OPTIONAL for you (video consent declined).'
  : 'This task is required for study completion.';
const etaRec = (TASKS['ID'] && TASKS['ID'].estMinutes) ? `${TASKS['ID'].estMinutes} minutes` : 'a few minutes';
const reqsRec = (TASKS['ID'] && TASKS['ID'].requirements) || '‚Äî';

const instructionBox = document.getElementById('task-instructions');
if (instructionBox) {
  document.getElementById('task-title').textContent = TASKS['ID'].name;
  instructionBox.innerHTML = `
    <div class="info-box friendly-tip" style="margin-bottom:10px;">
      <strong>‚ö†Ô∏è Ready to Start ${TASKS['ID'].name}?</strong>
      <ul style="margin:8px 0 0 20px; text-align:left;">
        <li>${requiredTextRec}</li>
        <li>Having problems? Email us instead of skipping</li>
        <li>Estimated time: <strong>${etaRec}</strong></li>
        <li>Requirements/tips: <em>${reqsRec}</em></li>
      </ul>
    </div>
  `;
}

    }

    function isIOS() { return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; }

    async function checkSecureAndPermissions() {
      if (!window.isSecureContext) {
        const hint = location.protocol === 'http:' ? 'This page must be served over https.' : 'This page cannot run from a local file.';
        throw { code: 'NOT_SECURE', message: hint };
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw { code: 'NO_MEDIADEVICES', message: 'This browser does not support in-page recording.' };
      }
      if (!window.MediaRecorder) {
        throw {
          code: 'NO_MEDIARECORDER',
          message: 'This browser does not support in-page recording.'
        };
      }
      let cam = 'unknown', mic = 'unknown';
      let permissionsChecked = false;
      if (navigator.permissions && navigator.permissions.query) {
        try {
          const camPerm = await navigator.permissions.query({ name: 'camera' });
          const micPerm = await navigator.permissions.query({ name: 'microphone' });
          cam = (camPerm && camPerm.state) || 'unknown';
          mic = (micPerm && micPerm.state) || 'unknown';
          permissionsChecked = true;
        } catch (e) {
          console.warn('Permission query failed:', e);
        }
      } else {
        console.warn('Permissions API not available; skipping permission pre-check.');
      }
      return { cam, mic, permissionsChecked };
    }

    function showRecordingError(html, showFallback = true) {
      const box = document.getElementById('recording-error');
      if (!box) return;
      box.style.display = 'block';
      box.innerHTML = html;
      if (showFallback) {
        const fb = document.getElementById('video-upload-fallback');
        if (fb) fb.style.display = 'block';
      }
    }

    // Enhanced file upload handling for the fallback option
    function enhanceUploadFallback() {
      const fallbackDiv = document.getElementById('video-upload-fallback');
      if (fallbackDiv) {
        fallbackDiv.innerHTML = `
  <h3>üìÅ Upload a Recording Instead</h3>
  <div class="info-box helpful" style="margin: 15px 0;">
    <strong>Upload Instructions:</strong>
    <ol style="margin: 8px 0 0 20px; text-align: left;">
      <li>Record a 30-60 second video/audio on your device</li>
      <li>Accepted formats: MP4, MOV, WebM (video) or MP3, M4A, WAV (audio)</li>
      <li>Maximum size: 50MB for MP4/MOV, 40MB for WebM, 25MB for audio</li>
      <li>Select your file below</li>
    </ol>
  </div>
  <input type="file" 
         id="video-file-input" 
         accept="video/mp4,video/quicktime,video/webm,video/*,audio/mp3,audio/mpeg,audio/m4a,audio/wav,audio/*,.mp4,.mov,.webm,.mp3,.m4a,.wav" 
         style="margin: 15px 0; padding: 10px; border: 2px solid var(--gray-300); border-radius: 8px; width: 100%;" />
  <div id="file-info" style="margin: 10px 0; font-weight: bold;"></div>
  <div class="button-group">
    <button class="button success" id="upload-save-btn" style="display:none;">Upload This File</button>
  </div>
  <p style="font-size: 14px; color: var(--text-secondary); margin-top: 10px;">
    üí° Tips: Use Camera app for video (iPhone/Android) or Voice Memos for audio (iPhone) or Voice Recorder (Android)
  </p>
`;
      }
    }

    function bindUploadFallback() {
      const input = document.getElementById('video-file-input');
      const btn = document.getElementById('upload-save-btn');
      const info = document.getElementById('file-info');
      if (!input || !btn || !info) return;

      input.addEventListener('change', () => {
        const f = input.files && input.files[0];
        if (!f) return;

        if (!f.type.startsWith('video/') && !f.type.startsWith('audio/')) {
          alert('Please select a video or audio file');
          input.value = '';
          info.textContent = '';
          btn.style.display = 'none';
          return;
        }

        // Determine format for size limit
        let format = 'audio';
        if (f.type.includes('mp4') || f.name.toLowerCase().endsWith('.mp4')) format = 'mp4';
        else if (f.type.includes('quicktime') || f.name.toLowerCase().endsWith('.mov')) format = 'mov';
        else if (f.type.includes('webm') || f.name.toLowerCase().endsWith('.webm')) format = 'webm';
        else if (f.type.startsWith('video/')) format = 'other-video';

        const sizeLimits = { mp4: 50, mov: 50, webm: 40, 'other-video': 40, audio: 25 };
        const maxMB = sizeLimits[format];
        const sizeMB = f.size / (1024 * 1024);
        if (sizeMB > maxMB) {
          alert(`File too large: ${sizeMB.toFixed(1)}MB. Maximum for ${format.toUpperCase()} is ${maxMB}MB.`);
          input.value = '';
          info.textContent = '';
          btn.style.display = 'none';
          return;
        }

        state.recording.currentBlob = f;
        info.textContent = `${f.name} (${sizeMB.toFixed(1)}MB)`;
        btn.style.display = 'inline-block';
      });

      btn.addEventListener('click', saveRecording);
    }

function bindRecordingSkips() {
      const btn1 = document.getElementById('skip-recording-btn');
      if (btn1) btn1.addEventListener('click', () => showSkipDialog('ID'));
      const btn2 = document.getElementById('skip-recording-consent-btn');
      if (btn2) btn2.addEventListener('click', () => showSkipDialog('ID'));
    }

    async function toggleRecording() {
      const btn = document.getElementById('record-btn');
      const status = document.getElementById('recording-status');
      const preview = document.getElementById('video-preview');

      if (!state.recording.active) {
        try {
          // First check permissions
          const perm = await checkSecureAndPermissions();
          if (perm.permissionsChecked && (perm.cam === 'denied' || perm.mic === 'denied')) {
            const how = isIOS()
              ? 'Settings ‚Üí Safari ‚Üí Camera/Microphone ‚Üí Allow for this site, then reload.'
              : 'Click the camera icon in the address bar and allow camera and microphone, then reload.';
            showRecordingError(`<strong>Camera or microphone is blocked</strong><p style="margin-top: 6px;">Please allow access for this site. ${how}</p>`);
            return;
          } else if (!perm.permissionsChecked) {
            console.warn('Permissions API unsupported; unable to pre-check camera/microphone permissions.');
          }

          // Try video first, fall back to audio-only if needed
          let stream;
          let isVideoMode = true;

          try {
            // Try to get both video and audio
            stream = await navigator.mediaDevices.getUserMedia({
              video: { width: 640, height: 480 },
              audio: true
            });
            isVideoMode = true;
          } catch (videoError) {
            console.warn('Video capture failed, trying audio-only:', videoError);

            // Fall back to audio-only
            try {
              stream = await navigator.mediaDevices.getUserMedia({
                audio: true,
                video: false
              });
              isVideoMode = false;

              // Show a notice that we're in audio-only mode
              const audioNotice = document.createElement('div');
              audioNotice.className = 'info-box helpful';
              audioNotice.innerHTML = `
            <strong>üì¢ Audio-Only Mode</strong>
            <p>Recording voice only (camera not available). This is fine for the task!</p>
          `;
              document.getElementById('recording-content').insertBefore(
                audioNotice,
                document.querySelector('.recording-controls')
              );
            } catch (audioError) {
              console.error('Audio capture also failed:', audioError);
              throw audioError;
            }
          }

          state.recording.stream = stream;
          state.recording.isVideoMode = isVideoMode;

          if (isVideoMode) {
            preview.srcObject = stream;
            preview.style.display = 'block';
          } else {
            preview.style.display = 'none';
            // Show audio visualization or indicator
            status.textContent = 'üé§ Audio ready to record';
          }

          if (!window.MediaRecorder) {
            showRecordingError(`<strong>Recording not supported in this browser</strong><p style="margin-top: 6px;">Please record using your device's camera or voice recorder, then upload the file below.</p>`);
            return;
          }

          // Determine best format based on mode and browser support
          // Detect best format with size optimization
          let options = {};
          let recordingFormat = 'webm'; // default

          if (isVideoMode) {
            const formatTests = [
              { mime: 'video/mp4;codecs=h264,aac', format: 'mp4', ext: 'mp4' },
              { mime: 'video/webm;codecs=vp9,opus', format: 'webm-vp9', ext: 'webm' },
              { mime: 'video/webm;codecs=vp8,opus', format: 'webm-vp8', ext: 'webm' },
              { mime: 'video/webm', format: 'webm', ext: 'webm' }
            ];

            for (const test of formatTests) {
              if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(test.mime)) {
                options.mimeType = test.mime;
                recordingFormat = test.ext;
                console.log(`Recording format selected: ${test.format} (${test.mime})`);
                break;
              }
            }

            // Add bitrate limits to reduce file size (CRITICAL)
            options.videoBitsPerSecond = 500000; // 500 kbps video
            options.audioBitsPerSecond = 64000;  // 64 kbps audio

            // Store format for later use
            state.recording.recordingFormat = recordingFormat;
            state.recording.recordingMimeType = options.mimeType || 'video/webm';
          } else {
            // Audio-only formats
            if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
              options.mimeType = 'audio/webm;codecs=opus';
            } else if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
              options.mimeType = 'audio/ogg;codecs=opus';
            } else if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/mp4')) {
              options.mimeType = 'audio/mp4';
            }

            // Store audio format info
            state.recording.recordingFormat = 'webm';
            state.recording.recordingMimeType = options.mimeType || 'audio/webm';
          }

          state.recording.mediaRecorder = new MediaRecorder(stream, options);
          state.recording.chunks = [];

          state.recording.mediaRecorder.ondataavailable = e => {
            if (e.data && e.data.size > 0) state.recording.chunks.push(e.data);
          };

          state.recording.mediaRecorder.onstop = () => {
            try {
              revokeRecordedURL();

              const mimeType = state.recording.recordingMimeType || (isVideoMode ? 'video/webm' : 'audio/webm');
              const blob = new Blob(state.recording.chunks, { type: mimeType });

              // Attach format metadata to blob for upload
              blob.recordingFormat = state.recording.recordingFormat || (isVideoMode ? 'webm' : 'webm');
              blob.recordingMimeType = mimeType;

              if (!isVideoMode) {
                const audioPlayer = document.createElement('audio');
                audioPlayer.id = 'recorded-audio';
                audioPlayer.controls = true;
                audioPlayer.style.width = '100%';
                audioPlayer.src = URL.createObjectURL(blob);

                const container = document.getElementById('recorded-video').parentElement;
                const existingAudio = document.getElementById('recorded-audio');
                if (existingAudio) existingAudio.remove();
                container.insertBefore(audioPlayer, document.getElementById('recorded-video'));
                document.getElementById('recorded-video').style.display = 'none';
              } else {
                const url = URL.createObjectURL(blob);
                const recordedEl = document.getElementById('recorded-video');
                recordedEl.src = url;
                recordedEl.style.display = 'block';
                preview.style.display = 'none';
              }

              document.getElementById('record-btn').style.display = 'none';
              document.getElementById('rerecord-btn').style.display = 'inline-block';
              document.getElementById('save-recording-btn').style.display = 'inline-block';

              const format = blob.recordingFormat === 'mp4' ? 'MP4' : (isVideoMode ? 'WebM' : 'Audio');
              const sizeKB = Math.round(blob.size / 1024);
              const sizeMB = (blob.size / (1024 * 1024)).toFixed(1);

              status.textContent = `Recording complete (${format}, ${sizeMB}MB)`;
              status.className = 'recording-status recorded';

              if (blob.size > 25 * 1024 * 1024) {
                const warningDiv = document.createElement('div');
                warningDiv.className = 'info-box warning';
                warningDiv.innerHTML = `
        <strong>‚ö†Ô∏è Large file warning</strong>
        <p>Your recording is ${sizeMB}MB. Files over 25MB may fail to upload. Consider re-recording with a shorter description (30-45 seconds).</p>
      `;
                document.querySelector('.recording-controls').appendChild(warningDiv);
              }

              state.recording.currentBlob = blob;

            } catch (e) {
              console.error('Finalize error:', e);
              alert('There was an issue finalizing the recording. Please try the upload option below.');
            }
          };

          state.recording.mediaRecorder.start();
          state.recording.active = true;
          btn.textContent = 'Stop Recording';
          btn.className = 'button danger';
          status.textContent = isVideoMode ? 'üî¥ Recording video...' : 'üé§ Recording audio...';
          status.className = 'recording-status recording';
          startRecordingTimer();

        } catch (err) {
          console.error('Recording error:', err);
          handleRecordingError(err);
        }
      } else {
        // Stop recording (existing code)
        try {
          if (state.recording.mediaRecorder && state.recording.mediaRecorder.state !== 'inactive') {
            state.recording.mediaRecorder.stop();
          }
        } catch(e) {
          console.warn('Stop error:', e);
        } finally {
          if (state.recording.stream) {
            try {
              state.recording.stream.getTracks().forEach(track => track.stop());
            } catch(e) {}
          }
          state.recording.active = false;
          btn.textContent = 'Start Recording';
          btn.className = 'button danger';
          stopRecordingTimer();
        }
      }
    }

    function handleRecordingError(err) {
      const name = (err && (err.name || err.code)) || 'Unknown';

      // More helpful error messages
      const errorMessages = {
        'NOT_SECURE': {
          title: 'Secure connection required',
          message: 'This page must be served over HTTPS for recording to work.',
          showUpload: true
        },
        'NotAllowedError': {
          title: 'Permission needed',
          message: 'Please allow camera and/or microphone access. If no prompt appeared, check your browser settings and refresh after granting permission.',
          showUpload: true
        },
        'NotFoundError': {
          title: 'No recording device found',
          message: 'No camera or microphone detected. You can upload a recording instead.',
          showUpload: true
        },
        'NotReadableError': {
          title: 'Device in use',
          message: 'Camera or microphone is being used by another application. Please close other apps and try again.',
          showUpload: true
        },
        'NO_MEDIARECORDER': {
          title: 'Recording not supported',
          message: 'This browser cannot record directly. Use your device\'s camera or voice recorder and upload the file below.',
          showUpload: true
        }
      };

      const errorInfo = errorMessages[name] || {
        title: 'Recording not available',
        message: `${(err && err.message) || 'Recording failed'}. You can upload a file instead.`,
        showUpload: true
      };

      showRecordingError(
        `<strong>${errorInfo.title}</strong>
     <p style="margin-top: 6px;">${errorInfo.message}</p>`,
        errorInfo.showUpload
      );
    }

    function reRecord() { cleanupRecording(true).finally(() => updateRecordingImage()); }

    // Updated saveRecording function with Google Drive upload
// Updated saveRecording function with enhanced logging
async function saveRecording() {
  if (!state.recording.currentBlob) {
    alert('Please record or upload a recording first.');
    return;
  }

  const saveBtn = document.getElementById('save-recording-btn');
  const originalText = saveBtn.textContent;
  saveBtn.disabled = true;
  saveBtn.textContent = 'Processing...';

  const status = document.getElementById('recording-status');
  status.textContent = '‚öôÔ∏è Processing recording...';
  status.className = 'recording-status recording';

  const uploadProgress = document.getElementById('upload-progress');
  uploadProgress.style.display = 'block';

  const recType = state.recording.isVideoMode ? 'video'
    : (state.recording.currentBlob && state.recording.currentBlob.type && state.recording.currentBlob.type.startsWith('audio') ? 'audio' : 'video');

  if (!localStorage.getItem('dropbox_access_token')) {
    const authState = {
      sessionCode: state.sessionCode,
      imageNumber: state.recording.currentImage + 1,
      blob: state.recording.currentBlob
    };
    try {
      const token = await initiateDropboxAuth(authState);
      if (!token) {
        uploadProgress.style.display = 'none';
        status.textContent = 'üìõ Please allow pop-ups to authorize Dropbox.';
        status.className = 'recording-status error';
        saveBtn.disabled = false;
        saveBtn.textContent = originalText;
        return;
      }
    } catch (e) {
      uploadProgress.style.display = 'none';
      status.textContent = 'üìõ Dropbox authorization failed.';
      status.className = 'recording-status error';
      saveBtn.disabled = false;
      saveBtn.textContent = originalText;
      return;
    }
  }

  sendToSheets({
    action: 'image_recorded',
    sessionCode: state.sessionCode,
    imageNumber: state.recording.currentImage + 1,
    timestamp: new Date().toISOString(),
    recordingType: recType
  });

  sendToSheets({
    action: 'video_recorded',
    sessionCode: state.sessionCode,
    imageNumber: state.recording.currentImage + 1,
    timestamp: new Date().toISOString(),
    recordingType: recType
  });

  try {
    // Upload with enhanced tracking
    const uploadResult = await uploadVideoToDrive(
      state.recording.currentBlob,
      state.sessionCode,
      state.recording.currentImage + 1
    );

    if (uploadResult.success) {
      // Store the upload info with method tracking
      state.recording.recordings.push({
        image: state.recording.currentImage + 1,
        blob: state.recording.currentBlob,
        timestamp: new Date().toISOString(),
        driveFileId: uploadResult.fileId,
        driveFileUrl: uploadResult.fileUrl,
        filename: uploadResult.filename,
        uploadMethod: uploadResult.uploadMethod,
        dropboxPath: uploadResult.dropboxPath || '',
        recordingType: state.recording.isVideoMode ? 'video' : 'audio',
        mimeType: state.recording.currentBlob.type
      });

      // Enhanced logging to Google Sheets
      const logData = {
        action: 'image_recorded_and_uploaded',
        sessionCode: state.sessionCode,
        imageNumber: state.recording.currentImage + 1,
        driveFileId: uploadResult.fileId,
        filename: uploadResult.filename,
        timestamp: new Date().toISOString(),
        deviceType: state.isMobile ? 'mobile/tablet' : 'desktop',
        // Enhanced fields
        uploadMethod: uploadResult.uploadMethod,
        dropboxPath: uploadResult.dropboxPath || '',
        fileSize: Math.round(state.recording.currentBlob.size / 1024),
        uploadStatus: 'success',
        recordingType: state.recording.isVideoMode ? 'video' : 'audio',
        mimeType: state.recording.currentBlob.type
      };

      // Send to both the task logging and video upload logging
      sendToSheets(logData);
      
      // Also log specifically to video uploads table
        sendToSheets({
          action: 'log_video_upload',
          sessionCode: state.sessionCode,
          imageNumber: state.recording.currentImage + 1,
          filename: uploadResult.filename,
          fileId: uploadResult.fileId,
          fileUrl: uploadResult.fileUrl,
          fileSize: Math.round(state.recording.currentBlob.size / 1024),
          uploadTime: new Date().toISOString(),
          uploadMethod: uploadResult.uploadMethod,
          dropboxPath: uploadResult.dropboxPath || '',
          uploadStatus: 'success',
          recordingType: state.recording.isVideoMode ? 'video' : 'audio',
          mimeType: state.recording.currentBlob.type
        });

      status.textContent = `‚úÖ Upload complete via ${uploadResult.uploadMethod}!`;
      status.className = 'recording-status recorded';
      uploadProgress.style.display = 'none';

      setTimeout(() => {
        if (state.recording.currentImage === 0) { 
          state.recording.currentImage = 1; 
          updateRecordingImage(); 
        } else { 
          completeTask('ID'); 
        }
      }, 1000);

    } else {
      throw new Error(uploadResult.error || 'Upload failed');
    }

  } catch (error) {
    console.error('Upload error:', error);

    // Enhanced error logging
    sendToSheets({
      action: 'log_video_upload_error',
      sessionCode: state.sessionCode,
      imageNumber: state.recording.currentImage + 1,
      error: error.message,
      timestamp: new Date().toISOString(),
      deviceType: state.isMobile ? 'mobile/tablet' : 'desktop',
      attemptedMethod: 'drive_then_dropbox',
      fallbackUsed: error.message.includes('Dropbox'),
      recordingType: state.recording.isVideoMode ? 'video' : 'audio',
      mimeType: state.recording.currentBlob.type
    });

    status.textContent = '‚ö†Ô∏è Upload failed. Retrying...';
    status.className = 'recording-status recording';
    enqueueFailedUpload(state.recording.currentBlob, state.sessionCode, state.recording.currentImage + 1);
  } finally {
    saveBtn.disabled = false;
    saveBtn.textContent = originalText;
  }
}

// Updated continueWithoutUpload with enhanced logging
function continueWithoutUpload() {
  if (confirm('Continue without uploading the video? The recording will only be saved locally in your browser.')) {
    state.recording.recordings.push({
      image: state.recording.currentImage + 1,
      blob: state.recording.currentBlob,
      timestamp: new Date().toISOString(),
      uploadSkipped: true,
      uploadMethod: 'local_only',
      recordingType: state.recording.isVideoMode ? 'video' : 'audio',
      mimeType: state.recording.currentBlob.type
    });

    // Enhanced logging for skipped upload
    sendToSheets({
      action: 'image_recorded_no_upload',
      sessionCode: state.sessionCode,
      imageNumber: state.recording.currentImage + 1,
      reason: 'Upload failed - continued locally',
      timestamp: new Date().toISOString(),
      deviceType: state.isMobile ? 'mobile/tablet' : 'desktop',
      uploadMethod: 'local_only',
      uploadStatus: 'skipped',
      recordingType: state.recording.isVideoMode ? 'video' : 'audio',
      mimeType: state.recording.currentBlob.type
    });

    if (state.recording.currentImage === 0) { 
      state.recording.currentImage = 1; 
      updateRecordingImage(); 
    } else { 
      completeTask('ID'); 
    }
    
    document.getElementById('recording-error').style.display = 'none';
  }
}

// Enhanced upload function - tries Google Drive first, Dropbox as fallback
function getExtensionFromMime(mime) {
  if (!mime) return 'bin';
  mime = mime.toLowerCase();
  if (mime.includes('mp4') || mime.includes('m4a')) return 'mp4';
  if (mime.includes('ogg')) return 'ogg';
  if (mime.includes('wav')) return 'wav';
  if (mime.includes('webm')) return 'webm';
  return 'bin';
}

    async function uploadToCloudinary(videoBlob, sessionCode, imageNumber) {
  try {
    console.log('Starting Cloudinary upload...');
    console.log('Config check:', {
      cloudName: CONFIG.CLOUDINARY_CLOUD_NAME,
      uploadPreset: CONFIG.CLOUDINARY_UPLOAD_PRESET
    });
    
    // Verify config
    if (!CONFIG.CLOUDINARY_CLOUD_NAME) {
      throw new Error('Cloudinary cloud name not configured');
    }
    if (!CONFIG.CLOUDINARY_UPLOAD_PRESET) {
      throw new Error('Cloudinary upload preset not configured');
    }
    
    // Create form data
    const formData = new FormData();
    formData.append('file', videoBlob);
    formData.append('upload_preset', CONFIG.CLOUDINARY_UPLOAD_PRESET);
    
    // Create a unique filename
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `${sessionCode}/image${imageNumber}_${timestamp}`;
    formData.append('public_id', filename);
    
    // Set the folder
    formData.append('folder', 'spatial-cognition-videos');
    
    // Log what we're sending
    console.log('Sending to Cloudinary:', {
      url: `https://api.cloudinary.com/v1_1/${CONFIG.CLOUDINARY_CLOUD_NAME}/video/upload`,
      preset: CONFIG.CLOUDINARY_UPLOAD_PRESET,
      folder: 'spatial-cognition-videos'
    });
    
    // Actually upload
    const response = await fetch(
      `https://api.cloudinary.com/v1_1/${CONFIG.CLOUDINARY_CLOUD_NAME}/video/upload`,
      {
        method: 'POST',
        body: formData
      }
    );
    
    // Get response text for debugging
    const responseText = await response.text();
    console.log('Cloudinary response:', responseText);
    
    if (!response.ok) {
      // Parse error details
      let errorDetail = responseText;
      try {
        const errorJson = JSON.parse(responseText);
        errorDetail = (errorJson.error && errorJson.error.message) || responseText;
      } catch (e) {
        // responseText is not JSON
      }
      
      console.error('Cloudinary error details:', errorDetail);
      throw new Error(`Cloudinary error: ${errorDetail}`);
    }
    
    // Parse successful response
    const result = JSON.parse(responseText);
    console.log('Cloudinary upload successful:', result);
    
    return {
      success: true,
      url: result.secure_url,
      publicId: result.public_id,
      format: result.format,
      size: result.bytes,
      duration: result.duration
    };
    
  } catch (error) {
    console.error('Cloudinary upload failed:', error);
    return {
      success: false,
      error: error.message
    };
  }
}
// Makes a valid 0.8s WebM by recording a tiny canvas
async function makeTinyTestVideo({ ms = 800, fps = 10 } = {}) {
  const canvas = document.createElement('canvas');
  canvas.width = 64; canvas.height = 64;
  const ctx = canvas.getContext('2d');

  // Pick a supported WebM mime
  const mime =
    MediaRecorder?.isTypeSupported?.('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' :
    MediaRecorder?.isTypeSupported?.('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' :
    'video/webm';

  const stream = canvas.captureStream?.(fps);
  if (!stream) throw new Error('Canvas captureStream is not supported in this browser');

  const rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 250000 });
  const chunks = [];
  rec.ondataavailable = e => { if (e.data && e.data.size > 0) chunks.push(e.data); };

  // Animate a little square so there are multiple frames
  let t = 0;
  const drawId = setInterval(() => {
    ctx.fillStyle = '#111'; ctx.fillRect(0, 0, 64, 64);
    ctx.fillStyle = '#fff'; ctx.fillRect((t * 3) % 64, (t * 2) % 64, 16, 16);
    t++;
  }, Math.round(1000 / fps));

  rec.start(100);
  await new Promise(r => setTimeout(r, ms));
  rec.stop();
  await new Promise(r => rec.onstop = r);

  clearInterval(drawId);
  stream.getTracks().forEach(tr => tr.stop());

  return new Blob(chunks, { type: 'video/webm' });
}

async function testCloudinaryUpload() {
  console.log('üß™ Testing Cloudinary setup...');
  console.log('Config check:', {
    cloudName: CONFIG.CLOUDINARY_CLOUD_NAME,
    uploadPreset: CONFIG.CLOUDINARY_UPLOAD_PRESET,
    folder: 'spatial-cognition-videos'
  });

  if (!CONFIG.CLOUDINARY_CLOUD_NAME || !CONFIG.CLOUDINARY_UPLOAD_PRESET) {
    alert('Set CONFIG.CLOUDINARY_CLOUD_NAME and CONFIG.CLOUDINARY_UPLOAD_PRESET first.');
    return;
  }

  let blob;
  try {
    // Try to generate a tiny WebM
    blob = await makeTinyTestVideo();
  } catch {
    // Fallback: let you pick any small mp4 or webm
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'video/mp4,video/webm,video/quicktime';
    input.click();
    const file = await new Promise(resolve => input.onchange = () => resolve(input.files?.[0]));
    if (!file) { alert('No file selected.'); return; }
    blob = file;
  }

  const result = await uploadToCloudinary(blob, 'TEST_' + Date.now(), 1);
  if (result.success) {
    console.log('‚úÖ SUCCESS! Video URL:', result.url);
    alert('Cloudinary is working! URL: ' + result.url);
  } else {
    console.error('‚ùå FAILED:', result.error);
    alert('Cloudinary setup has an issue: ' + result.error);
  }
}


// Add to your window exports at the bottom
window.testCloudinaryUpload = testCloudinaryUpload;
    
async function uploadVideoToDrive(videoBlob, sessionCode, imageNumber) {
  try {
    updateUploadProgress(5, 'Starting upload...');
    
    // TRY CLOUDINARY FIRST (NEW!)
    console.log('Trying Cloudinary first...');
    updateUploadProgress(10, 'Uploading to cloud storage...');
    
    const cloudinaryResult = await uploadToCloudinary(videoBlob, sessionCode, imageNumber);
    
    if (cloudinaryResult.success) {
      updateUploadProgress(100, 'Upload complete!');
      
      // Log to Google Sheets (just the URL, not the video data)
      await sendToSheets({
        action: 'log_video_upload',
        sessionCode: sessionCode,
        imageNumber: imageNumber,
        filename: `image${imageNumber}_${Date.now()}.webm`,
        fileId: cloudinaryResult.publicId,
        fileUrl: cloudinaryResult.url,
        fileSize: Math.round(cloudinaryResult.size / 1024), // KB
        uploadTime: new Date().toISOString(),
        uploadMethod: 'cloudinary',
        uploadStatus: 'success'
      });
      
      return {
        success: true,
        filename: cloudinaryResult.publicId,
        fileId: cloudinaryResult.publicId,
        fileUrl: cloudinaryResult.url,
        uploadMethod: 'cloudinary'
      };
    } else {
      console.log('Cloudinary failed, trying Google Drive fallback...');
      updateUploadProgress(30, 'Trying backup upload method...');
      
      // YOUR EXISTING GOOGLE DRIVE CODE STAYS AS FALLBACK
      // (Keep your existing code here as backup)
      return await uploadToGoogleDrive(videoBlob, sessionCode, imageNumber);
    }
    
  } catch (error) {
    console.error('All upload methods failed:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

// Updated Dropbox upload function (now fallback)
async function uploadToDropboxRegularFolder(videoBlob, sessionCode, imageNumber) {
  try {
    const dbx = new Dropbox.Dropbox({
      clientId: 'nvkm67mvluiu4pf',
      fetch: fetch
    });
    const accessToken = localStorage.getItem('dropbox_access_token');
    if (!accessToken) {
      throw new Error('Dropbox not authorized');
    }

    dbx.setAccessToken(accessToken);
    updateUploadProgress(55, 'Preparing file...');

    if (videoBlob.size > 150 * 1024 * 1024) {
      throw new Error('Video too large for direct upload (max 150MB)');
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const extension = getExtensionFromMime(videoBlob.type);
    const filename = `${sessionCode}_image${imageNumber}_${timestamp}.${extension}`;

    const participantFolder = `/spatial-cognition-videos/Participant_${sessionCode}`;
    const fullPath = `${participantFolder}/${filename}`;

    updateUploadProgress(60, 'Uploading to Dropbox...');

    try {
      await dbx.filesCreateFolderV2({
        path: participantFolder,
        autorename: false
      });
    } catch (folderError) {
      if (!folderError.error || !folderError.error.error_summary.includes('path/conflict')) {
        console.warn('Folder creation issue:', folderError);
      }
    }

    const response = await dbx.filesUpload({
      path: fullPath,
      contents: videoBlob,
      mode: 'add',
      autorename: true
    });

    updateUploadProgress(80, 'Getting shareable link...');

    let shareUrl = '';
    try {
      const shareResponse = await dbx.sharingCreateSharedLinkWithSettings({
        path: fullPath,
        settings: {
          access: 'viewer',
          allow_download: true,
          audience: 'public'
        }
      });
      shareUrl = shareResponse.result.url;
    } catch (shareError) {
      console.warn('Could not create share link:', shareError);
      shareUrl = `https://dropbox.com/home/spatial-cognition-videos/Participant_${sessionCode}`;
    }

    updateUploadProgress(90, 'Upload complete!');

    return {
      success: true,
      filename: filename,
      fileId: response.result.id,
      fileUrl: shareUrl,
      dropboxPath: fullPath,
      fileSize: Math.round(videoBlob.size / 1024)
    };

  } catch (error) {
    console.error('Dropbox upload failed:', error);

    if ((error.message && error.message.includes('auth')) || error.status === 401) {
      localStorage.removeItem('dropbox_access_token');
    }

    return {
      success: false,
      error: error.message || String(error)
    };
  }
}

async function uploadToGoogleDrive(videoBlob, sessionCode, imageNumber) {
  try {
    updateUploadProgress(15, 'Preparing upload‚Ä¶');

    // Detect format from blob metadata, with multiple fallbacks
    let videoFormat = 'webm'; // ultimate fallback

    // Priority 1: Check blob metadata we added
    if (videoBlob.recordingFormat) {
      videoFormat = videoBlob.recordingFormat;
    }
    // Priority 2: Check MIME type
    else if (videoBlob.type) {
      if (videoBlob.type.includes('mp4') || videoBlob.type.includes('mpeg4')) {
        videoFormat = 'mp4';
      } else if (videoBlob.type.includes('quicktime')) {
        videoFormat = 'mov';
      } else if (videoBlob.type.includes('webm')) {
        videoFormat = 'webm';
      }
    }
    // Priority 3: Check file name if this is an uploaded file
    else if (videoBlob.name) {
      const ext = videoBlob.name.split('.').pop().toLowerCase();
      if (['mp4', 'mov', 'webm', 'avi', 'mkv'].includes(ext)) {
        videoFormat = ext;
      }
    }

    console.log(`Upload format detected: ${videoFormat}, size: ${(videoBlob.size/1024/1024).toFixed(2)}MB`);

    // Format-specific size limits
    const sizeLimits = {
      'mp4': 55 * 1024 * 1024,  // 55MB for MP4 (more compressed)
      'mov': 50 * 1024 * 1024,  // 50MB for MOV
      'webm': 40 * 1024 * 1024, // 40MB for WebM (less compressed)
      'avi': 35 * 1024 * 1024,  // 35MB for AVI
      'mkv': 40 * 1024 * 1024   // 40MB for MKV
    };

    const maxSize = sizeLimits[videoFormat] || 35 * 1024 * 1024;

    if (videoBlob.size > maxSize) {
      const currentMB = (videoBlob.size / (1024 * 1024)).toFixed(1);
      const maxMB = (maxSize / (1024 * 1024)).toFixed(0);
      throw new Error(`Video too large: ${currentMB}MB. Maximum for ${videoFormat.toUpperCase()}: ${maxMB}MB. Please record a shorter video (30-45 seconds).`);
    }

    updateUploadProgress(20, `Converting ${videoFormat} for upload...`);
    const base64DataUrl = await blobToBase64(videoBlob);
    const base64VideoData = base64DataUrl.split(',')[1] || base64DataUrl.split(',').pop();

    updateUploadProgress(25, 'Encoding complete...');

    const uploadData = {
      action: 'upload_video',
      sessionCode: sessionCode,
      imageNumber: imageNumber,
      videoData: base64VideoData,
      videoFormat: videoFormat,        // CRITICAL: Send format to backend
      mimeType: videoBlob.type || '',  // Send MIME type too
      fileName: videoBlob.name || '',  // Send filename if available
      fileSize: videoBlob.size,
      timestamp: new Date().toISOString()
    };

    updateUploadProgress(30, `Uploading ${videoFormat.toUpperCase()} to Google Drive...`);

    const response = await fetch(CONFIG.SHEETS_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain;charset=utf-8' },
      body: JSON.stringify(uploadData)
    });

    updateUploadProgress(75, 'Processing response...');

    let result;
    const contentType = response.headers.get('content-type');

    if (contentType && contentType.includes('application/json')) {
      result = await response.json();
    } else {
      const text = await response.text();
      try {
        result = JSON.parse(text);
      } catch (e) {
        console.error('Response text:', text);
        throw new Error('Invalid response format from server');
      }
    }

    if (!response.ok || !result.success) {
      throw new Error(result.error || result.details || `Upload failed (${response.status})`);
    }

    updateUploadProgress(100, 'Upload complete!');

    return {
      success: true,
      filename: result.filename,
      fileId: result.fileId,
      fileUrl: result.fileUrl,
      format: result.format || videoFormat
    };

  } catch (error) {
    console.error('Google Drive upload error:', error);
    return {
      success: false,
      error: error.message || String(error)
    };
  }
}

    


    // Add this NEW function after uploadVideoToDrive
function updateUploadProgress(percent, message) {
  const progressDiv = document.getElementById('upload-progress');
  const progressFill = document.getElementById('upload-progress-fill');
  const status = document.getElementById('upload-status');
  
  if (progressDiv) progressDiv.style.display = 'block';
  if (progressFill) progressFill.style.width = `${percent}%`;
  if (status) status.textContent = `${percent}%`;
  
  // Update the progress message
  const progressText = progressDiv ? progressDiv.querySelector('div[style*="font-weight: bold"]') : null;
  if (progressText && message) {
    progressText.textContent = message;
  }
}

    // Helper function to convert blob to base64
    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    function enqueueFailedUpload(blob, sessionCode, imageNumber) {
      state.uploadQueue.push({ blob, sessionCode, imageNumber, attempts: 0 });
      processUploadQueue();
    }

    async function processUploadQueue() {
      if (state.processingUpload || state.uploadQueue.length === 0) return;
      state.processingUpload = true;
      const item = state.uploadQueue[0];
      try {
        const uploadResult = await uploadVideoToDrive(item.blob, item.sessionCode, item.imageNumber);
        if (uploadResult.success) {
          handleUploadSuccess(uploadResult, item.imageNumber, item.blob);
          state.uploadQueue.shift();
        } else {
          throw new Error(uploadResult.error || 'Upload failed');
        }
      } catch (err) {
        item.attempts++;
        if (item.attempts < 3) {
          setTimeout(() => { state.processingUpload = false; processUploadQueue(); }, 5000 * item.attempts);
          return;
        }
        state.uploadQueue.shift();
        showUploadError(err, item.imageNumber, item.blob);
      }
      state.processingUpload = false;
      if (state.uploadQueue.length > 0) processUploadQueue();
    }

    function handleUploadSuccess(uploadResult, imageNumber, blob) {
      state.recording.recordings.push({
        image: imageNumber,
        blob,
        timestamp: new Date().toISOString(),
        driveFileId: uploadResult.fileId,
        driveFileUrl: uploadResult.fileUrl,
        filename: uploadResult.filename,
        uploadMethod: uploadResult.uploadMethod,
        dropboxPath: uploadResult.dropboxPath || '',
        recordingType: state.recording.isVideoMode ? 'video' : 'audio',
        mimeType: blob.type
      });

      const logData = {
        action: 'image_recorded_and_uploaded',
        sessionCode: state.sessionCode,
        imageNumber,
        driveFileId: uploadResult.fileId,
        filename: uploadResult.filename,
        timestamp: new Date().toISOString(),
        deviceType: state.isMobile ? 'mobile/tablet' : 'desktop',
        uploadMethod: uploadResult.uploadMethod,
        dropboxPath: uploadResult.dropboxPath || '',
        fileSize: Math.round(blob.size / 1024),
        uploadStatus: 'success',
        recordingType: state.recording.isVideoMode ? 'video' : 'audio',
        mimeType: blob.type
      };
      sendToSheets(logData);
      sendToSheets({
        action: 'log_video_upload',
        sessionCode: state.sessionCode,
        imageNumber,
        filename: uploadResult.filename,
        fileId: uploadResult.fileId,
        fileUrl: uploadResult.fileUrl,
        fileSize: Math.round(blob.size / 1024),
        uploadTime: new Date().toISOString(),
        uploadMethod: uploadResult.uploadMethod,
        dropboxPath: uploadResult.dropboxPath || '',
        uploadStatus: 'success',
        recordingType: state.recording.isVideoMode ? 'video' : 'audio',
        mimeType: blob.type
      });

      const status = document.getElementById('recording-status');
      status.textContent = `‚úÖ Upload complete via ${uploadResult.uploadMethod}!`;
      status.className = 'recording-status recorded';
      document.getElementById('upload-progress').style.display = 'none';

      setTimeout(() => {
        if (imageNumber === 1 && state.recording.currentImage === 0) {
          state.recording.currentImage = 1;
          updateRecordingImage();
        } else {
          completeTask('ID');
        }
      }, 1000);
    }

    function showUploadError(error, imageNumber, blob) {
      sendToSheets({
        action: 'log_video_upload_error',
        sessionCode: state.sessionCode,
        imageNumber,
        error: error.message,
        timestamp: new Date().toISOString(),
        deviceType: state.isMobile ? 'mobile/tablet' : 'desktop',
        attemptedMethod: 'drive_then_dropbox',
        fallbackUsed: error.message.includes('Dropbox'),
        recordingType: state.recording.isVideoMode ? 'video' : 'audio',
        mimeType: blob.type
      });

      const uploadProgress = document.getElementById('upload-progress');
      uploadProgress.style.display = 'none';
      const errorDiv = document.getElementById('recording-error');
      errorDiv.style.display = 'block';
      errorDiv.innerHTML = `
      <strong>Upload failed</strong>
      <p style="margin-top: 6px;">Error: ${error.message}. You can try again or continue without uploading. The video is saved locally in your browser.</p>
      <div class="button-group" style="margin-top: 10px;"><button class="button" onclick="retryVideoUpload()">Try Again</button><button class="button secondary" onclick="continueWithoutUpload()">Continue Without Upload</button></div>`;
      const status = document.getElementById('recording-status');
      status.textContent = '‚ùå Upload failed';
      status.className = 'recording-status ready';
    }

    // Retry upload function
    async function retryVideoUpload() {
      document.getElementById('recording-error').style.display = 'none';
      await saveRecording();
    }

      function cleanupRecording(keepPreviewUI = false) {
      return new Promise(resolve => {
        try {
          if (state.recording.mediaRecorder && state.recording.mediaRecorder.state !== 'inactive') {
            state.recording.mediaRecorder.addEventListener('stop', () => resolve(), { once: true });
            try { state.recording.mediaRecorder.stop(); } catch(e) { resolve(); }
          } else { resolve(); }
        } catch(e) { resolve(); }
      }).finally(() => {
        try { if (state.recording.stream) state.recording.stream.getTracks().forEach(t => t.stop()); } catch(e){}
        state.recording.stream = null;
        state.recording.active = false;
        state.recording.chunks = [];
        stopRecordingTimer();

        if (!keepPreviewUI) {
          const preview = document.getElementById('video-preview');
          if (preview) { if (preview.pause) preview.pause(); preview.srcObject = null; preview.style.display = 'none'; }
          const recorded = document.getElementById('recorded-video');
          if (recorded) { revokeRecordedURL(); recorded.style.display = 'none'; }
          state.recording.mediaRecorder = null;
        }
      });
    }

    function ensureTaskPointer(taskCode) {
      if (!state.sequence || !state.sequence.length) return;
      if (state.sequence[state.currentTaskIndex] !== taskCode) {
        const idx = state.sequence.indexOf(taskCode);
        if (idx !== -1) state.currentTaskIndex = idx;
      }
    }

    async function skipRecording() {
      if (!confirm('Unable to complete the image description task?')) return;
      try { await cleanupRecording(); } catch(e) { console.warn('Cleanup on skip failed silently:', e); }
      ensureTaskPointer('ID'); skipTask('ID');
    }

    let recordingTimer;
    function startRecordingTimer() {
      const timer = document.getElementById('recording-timer'); timer.style.display = 'block';
      let seconds = 0;
      state.recording.recordingStart = Date.now();
      recordingTimer = setInterval(() => {
        seconds++; const mins = Math.floor(seconds/60); const secs = seconds % 60;
        timer.textContent = `${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
      }, 1000);
    }
    function stopRecordingTimer() {
      clearInterval(recordingTimer);
      const t = document.getElementById('recording-timer'); if (t) t.style.display = 'none';
      if (state.recording.recordingStart) {
        state.recording.recordingDuration = Date.now() - state.recording.recordingStart;
      }
    }

    // ----- Complete/Skip -----
    function completeTask(taskCode) {
      const task = TASKS[taskCode]; if (!task) { console.error('Task not found:', taskCode); return; }
      taskTimer.stop();
      const summary = taskTimer.getSummary();
      state.totalTimeSpent += summary.elapsed;
      if (!state.completedTasks.includes(taskCode)) state.completedTasks.push(taskCode);
      state.skippedTasks = state.skippedTasks.filter(code => code !== taskCode);
      state.currentTaskIndex++;
      while (state.currentTaskIndex < state.sequence.length && state.completedTasks.includes(state.sequence[state.currentTaskIndex])) state.currentTaskIndex++;
      saveState();
        const payload = {
          sessionCode: state.sessionCode,
          task: getStandardTaskName(taskCode),
          elapsed: Math.round(summary.elapsed/1000),
          active: Math.round(summary.active/1000),
          pauseCount: summary.pauseCount,
          paused: Math.round(summary.paused/1000),
          inactive: Math.round(summary.inactive/1000),
          activity: Math.round(summary.activity),
          startTime: summary.start,
          endTime: summary.end,
          timestamp: new Date().toISOString(),
          deviceType: state.isMobile ? 'mobile/tablet' : 'desktop'
        };
        payload.action = task.skilled ? 'skilled_task_completed' : 'task_completed';
        if (taskCode === 'ID' && state.recording && state.recording.recordingDuration) {
          payload.recordingDuration = Math.round(state.recording.recordingDuration/1000);
        }
        sendToSheets(payload);
        logSessionTime(taskCode);
      state.currentTaskType = '';
      if (state.currentTaskIndex >= state.sequence.length) showCompletionScreen(); else showProgressScreen();
    }

    function skipTask(taskCode) {
      const task = TASKS[taskCode]; if (!task) { console.error('Task not found:', taskCode); return; }
      taskTimer.stop();
      if (taskCode === 'ID') {
        if (state.recording && (state.recording.stream || state.recording.active)) {
          try { if (state.recording.stream && state.recording.stream.getTracks) state.recording.stream.getTracks().forEach(t => t.stop()); } catch(e){}
          state.recording.active = false; state.recording.chunks = []; stopRecordingTimer();
        }
      }
      if (!state.completedTasks.includes(taskCode)) state.completedTasks.push(taskCode);
      if (!state.skippedTasks.includes(taskCode)) state.skippedTasks.push(taskCode);
      state.currentTaskIndex++;
      while (state.currentTaskIndex < state.sequence.length && state.completedTasks.includes(state.sequence[state.currentTaskIndex])) state.currentTaskIndex++;
      saveState();
      sendToSheets({
        action: 'task_skipped',
        sessionCode: state.sessionCode,
        task: getStandardTaskName(taskCode),
        reason: taskCode === 'ASLCT' ? 'Does not know ASL' : taskCode === 'ID' ? (state.consentStatus.videoDeclined ? 'Video consent declined' : 'User chose to skip') : 'User chose to skip',
        timestamp: new Date().toISOString(),
        deviceType: state.isMobile ? 'mobile/tablet' : 'desktop'
      });
      logSessionTime(taskCode + '_skipped');
      state.currentTaskType = '';
      if (state.currentTaskIndex >= state.sequence.length) showCompletionScreen(); else showProgressScreen();
    }

    // ----- Completion -----
    function showCompletionScreen() {
      document.getElementById('final-code').textContent = state.sessionCode;
      document.getElementById('total-time').textContent = Math.round(state.totalTimeSpent / 60000);
      showScreen('completion-screen');
      document.getElementById('pause-fab').classList.remove('active');
    }

    async function markComplete() {
      if (sessionTimer.startTime && !sessionTimer.endTime) sessionTimer.stop();
      const sessSummary = sessionTimer.getSummary();
      state.totalActiveTime = sessSummary.active;
      logSessionTime('final', sessSummary);
      const btn = document.getElementById('mark-complete-btn');
      btn.disabled = true;
      await sendToSheets({
        action: 'study_completed',
        sessionCode: state.sessionCode,
        status: 'Complete',
        totalDuration: Math.round(state.totalTimeSpent / 60000),
        deviceType: state.isMobile ? 'mobile/tablet' : 'desktop',
        timestamp: new Date().toISOString()
      });
      document.getElementById('completion-message').style.display = 'block';
    }

    // ----- Utilities -----
    function pauseStudy() {
      state.pauseStart = Date.now();
      state.lastPauseType = 'manual';
      if (taskTimer.startTime) taskTimer.pause('manual');
      if (sessionTimer.startTime) sessionTimer.pause('manual');
      document.getElementById('pause-modal').classList.add('active');
      document.getElementById('pause-fab').classList.remove('active');
        const { total, completed } = getTaskCounts();
        const progress = total ? `${completed}/${total}` : '';
        sendToSheets({ action: 'session_paused', sessionCode: state.sessionCode, progress, pauseType: 'manual', timestamp: new Date().toISOString() });
      saveState();
    }

    function resumeStudy() {
      if (state.pauseStart) {
        const pausedMs = Date.now() - state.pauseStart;
        state.totalPausedTime = (state.totalPausedTime || 0) + pausedMs;
        state.pauseStart = null;
          const { total, completed } = getTaskCounts();
          const progress = total ? `${completed}/${total}` : '';
          sendToSheets({ action: 'session_resumed', sessionCode: state.sessionCode, progress, pausedSeconds: Math.round(pausedMs/1000), pauseType: state.lastPauseType, timestamp: new Date().toISOString() });
      }
      if (taskTimer.startTime) taskTimer.resume();
      if (sessionTimer.startTime) sessionTimer.resume();
      document.getElementById('pause-modal').classList.remove('active');
      document.getElementById('pause-fab').classList.add('active');
      saveState();
    }

    function saveAndExit() {
      state.pauseStart = Date.now();
      state.lastPauseType = 'exit';
      if (taskTimer.startTime) taskTimer.pause('exit');
      if (sessionTimer.startTime) sessionTimer.pause('exit');
      saveState();
      document.getElementById('modal-code').textContent = state.sessionCode;
      document.getElementById('exit-modal').classList.add('active');
        const { total, completed } = getTaskCounts();
        const progress = total ? `${completed}/${total}` : '';
        sendToSheets({ action: 'session_paused', sessionCode: state.sessionCode, progress, pauseType: 'exit', timestamp: new Date().toISOString() });
    }
      function showCopyFeedback(btnEl) {
        if (!btnEl) return;
        const original = btnEl.textContent;
        btnEl.textContent = '‚úÖ Copied!';
        setTimeout(() => btnEl.textContent = original, 2000);
      }

      function fallbackCopy(text, btnEl) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        try {
          document.execCommand('copy');
          showCopyFeedback(btnEl);
          alert('Copied to clipboard: ' + text);
        } catch (err) {
          alert('Copy this text manually: ' + text);
        }
        document.body.removeChild(textarea);
      }

      function copyCode(btnEl) {
        const code = document.getElementById('display-code').textContent;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(code)
            .then(() => {
              showCopyFeedback(btnEl);
            })
            .catch(() => fallbackCopy(code, btnEl));
        } else {
          fallbackCopy(code, btnEl);
        }
      }
      function generateRecoveryLink() {
        if (!state.sessionCode) return '';
        const token = btoa(state.sessionCode);
        return `${location.origin}${location.pathname}?recover=${encodeURIComponent(token)}`;
      }
      function copyRecoveryLink(btnEl) {
        const link = generateRecoveryLink();
        if (!link) return;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(link)
            .then(() => {
              showCopyFeedback(btnEl);
            })
            .catch(() => fallbackCopy(link, btnEl));
        } else {
          fallbackCopy(link, btnEl);
        }
      }

      function copyASLCTCode(btnEl) {
        const code = CONFIG.ASLCT_ACCESS_CODE;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(code)
            .then(() => {
              showCopyFeedback(btnEl);
            })
            .catch(() => fallbackCopy(code, btnEl));
        } else {
          fallbackCopy(code, btnEl);
        }
      }

    function openEmbedInNewTab(taskCode) {
      const task = TASKS[taskCode];
      if (task && task.embedUrl) window.open(task.embedUrl, '_blank', 'noopener');
    }
    function reloadEmbed(iframeId) {
      const f = document.getElementById(iframeId);
      if (f) f.src = f.src;
    }

function scheduleEEG() {
  // Log the intent then open Calendly in a new tab
  sendToSheets({
    action: 'calendly_opened',
    sessionCode: state.sessionCode || 'none',
    participantID: state.participantID || 'none',
    timestamp: new Date().toISOString()
  });
  window.open(CONFIG.EEG_CALENDLY_URL, '_blank', 'noopener');
}

function expressEEGInterest() {
  sendToSheets({
    action: 'eeg_interest',
    sessionCode: state.sessionCode || 'none',
    participantID: state.participantID || 'none',
    timestamp: new Date().toISOString()
  });
  alert('Thanks! We will contact you when more EEG times are available.');
}

function markEEGScheduled() {
  // Optional prompt so you can capture a date-time string if the participant knows it
  var when = prompt('If you know your scheduled date-time, enter it here (optional). You can also leave this blank and press OK.');
  sendToSheets({
    action: 'eeg_scheduled',
    sessionCode: state.sessionCode || 'none',
    participantID: state.participantID || 'none',
    scheduledAt: when || new Date().toISOString(),
    source: 'Calendly',
    timestamp: new Date().toISOString()
  });
  alert('Thanks. We marked EEG as scheduled on our side.');
}

    let pendingSkipTask = null;
    function showSkipDialog(taskCode) {
      pendingSkipTask = taskCode;
      const pre = document.getElementById('pre-skip-modal');
      pre.classList.add('active');
    }
    document.getElementById('pre-skip-try-btn').onclick = () => {
      document.getElementById('pre-skip-modal').classList.remove('active');
    };
    document.getElementById('pre-skip-help-btn').onclick = () => {
      document.getElementById('pre-skip-modal').classList.remove('active');
      openSupportEmail(pendingSkipTask);
      sendToSheets({ action: 'help_requested', sessionCode: state.sessionCode || 'none', task: getStandardTaskName(pendingSkipTask), timestamp: new Date().toISOString() });
    };
    document.getElementById('pre-skip-break-btn').onclick = () => {
      document.getElementById('pre-skip-modal').classList.remove('active');
      pauseStudy();
    };
    document.getElementById('pre-skip-skip-btn').onclick = () => {
      document.getElementById('pre-skip-modal').classList.remove('active');
      document.getElementById('skip-modal').classList.add('active');
    };

    document.getElementById('skip-help-btn').onclick = () => {
      openSupportEmail(pendingSkipTask);
      sendToSheets({ action: 'help_requested', sessionCode: state.sessionCode || 'none', task: getStandardTaskName(pendingSkipTask), timestamp: new Date().toISOString() });
    };
    document.getElementById('skip-try-btn').onclick = () => {
      document.getElementById('skip-modal').classList.remove('active');
    };
    document.getElementById('skip-break-btn').onclick = () => {
      document.getElementById('skip-modal').classList.remove('active');
      pauseStudy();
    };
    document.getElementById('skip-confirm-btn').onclick = async () => {
      document.getElementById('skip-modal').classList.remove('active');
      await skipTaskProceed(pendingSkipTask);
    };

function openSupportEmail() {
  const subject = encodeURIComponent('Technical Support Request - Spatial Cognition Study');
  const body = encodeURIComponent(`Hi Action Brain Lab,

I need technical support with the spatial cognition study.

Device/Browser: 
Issue description: 
What I've tried: 
Accessibility needs (if any): 

Thank you!`);
  window.open(`mailto:${CONFIG.SUPPORT_EMAIL}?subject=${subject}&body=${body}`, '_blank');
}

// Do the actual skip (handles video task cleanup)
async function skipTaskProceed(taskCode) {
  if (taskCode === 'ID') {
    try { await cleanupRecording(); } catch(e) {}
  }
  // Call your existing skip function
  skipTask(taskCode);
}


    function hashCode(str) { let hash = 0; for (let i=0;i<str.length;i++){const c=str.charCodeAt(i); hash=((hash<<5)-hash)+c; hash|=0;} return hash; }

    function submitASLCTIssue() {
      const el = document.getElementById('aslct-issue-text');
      if (!el) return;
      const message = el.value.trim();
      if (!message) return;
      sendToSheets({
        action: 'aslct_issue',
        sessionCode: state.sessionCode || 'none',
        participantID: state.participantID || 'none',
        message,
        timestamp: new Date().toISOString()
      });
      el.value = '';
      alert('Issue submitted. Thank you!');
    }

    // === REPLACE sendToSheets with this ===
async function sendToSheets(payload) {
  if (!CONFIG.SHEETS_URL) return;

  const body = { ...payload, userAgent: navigator.userAgent, deviceType: payload.deviceType || (state.isMobile ? 'mobile/tablet' : 'desktop') };

  try {
    await fetch(CONFIG.SHEETS_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain;charset=utf-8' }, // simple request, no preflight
      body: JSON.stringify(body)
    });
  } catch (error) {
    console.error('Error sending to sheets:', error);
  }
}

window.addEventListener('beforeunload', () => {
  if (!CONFIG.SHEETS_URL) return;
  const body = {
    action: 'window_closed',
    sessionCode: state.sessionCode || 'none',
    task: getStandardTaskName(state.sequence[state.currentTaskIndex] || ''),
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent,
    deviceType: state.isMobile ? 'mobile/tablet' : 'desktop'
  };
  navigator.sendBeacon(CONFIG.SHEETS_URL, JSON.stringify(body));
});



    // ---------- OPTIONAL AUTH HELPERS (frontend) ----------


    // DEBUG FUNCTION - Add this before "// Expose to window"
 async function debugVideoUpload() {
  console.log('üîç Starting video upload debug...');
  
  // Test 1: Check configuration
  console.log('1. Configuration check:');
  console.log('SHEETS_URL:', CONFIG.SHEETS_URL);
  console.log('Is valid URL:', CONFIG.SHEETS_URL.includes('script.google.com'));
  
  // Test 2: Test basic connection
  console.log('2. Testing basic connection...');
  try {
    const res = await fetch(CONFIG.SHEETS_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain;charset=utf-8' },
      body: JSON.stringify({
        action: 'test_connection',
        timestamp: new Date().toISOString()
      })
    });

    console.log('‚úÖ Connection response:', {
      status: res.status,
      ok: res.ok,
      statusText: res.statusText,
      contentType: res.headers.get('content-type')
    });

    // Handle response carefully
    const text = await res.text();
    let payload;
    try {
      payload = JSON.parse(text);
    } catch {
      payload = text;
    }
    console.log('‚úÖ Connection result:', payload);
    
  } catch (error) {
    console.error('‚ùå Connection failed:', error);
    return;
  }

  // Test 3: Create a tiny test video blob
  console.log('3. Creating test video blob...');
  try {
    // Create a minimal test "video" (just some bytes)
    const testData = new Uint8Array([0x1A, 0x45, 0xDF, 0xA3]); // WebM magic number
    const testBlob = new Blob([testData], { type: 'video/webm' });
    
    console.log('Test blob created:', {
      size: testBlob.size,
      type: testBlob.type
    });
    
    // Test 4: Test base64 conversion
    console.log('4. Testing base64 conversion...');
    const base64Data = await blobToBase64(testBlob);
    const base64VideoData = base64Data.split(',')[1];
    
    console.log('‚úÖ Base64 conversion successful:', {
      originalSize: testBlob.size,
      base64Length: base64VideoData.length
    });
    
    // Test 5: Test actual upload
    console.log('5. Testing upload with tiny file...');
    const uploadData = {
      action: 'upload_video',
      sessionCode: 'DEBUG_' + Date.now(),
      imageNumber: 99,
      videoData: base64VideoData,
      mimeType: testBlob.type,
      timestamp: new Date().toISOString()
    };
    
    const uploadResponse = await fetch(CONFIG.SHEETS_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain;charset=utf-8' },
      body: JSON.stringify(uploadData)
    });
    
    console.log('Upload response:', {
      status: uploadResponse.status,
      ok: uploadResponse.ok,
      statusText: uploadResponse.statusText,
      contentType: uploadResponse.headers.get('content-type')
    });
    
    const uploadText = await uploadResponse.text();
    let uploadResult;
    try {
      uploadResult = JSON.parse(uploadText);
    } catch {
      uploadResult = uploadText;
    }
    
    if (uploadResponse.ok && uploadResult.success) {
      console.log('‚úÖ Upload successful:', uploadResult);
      
      // Note about cleanup
      if (uploadResult.fileId) {
        console.log('üßπ Test file created with ID:', uploadResult.fileId);
        console.log('Note: You may want to delete this test file from Google Drive');
      }
    } else {
      console.error('‚ùå Upload failed:', uploadResult);
    }
    
  } catch (error) {
    console.error('‚ùå Debug test failed:', error);
  }
  
  console.log('üîç Debug complete! Check the console messages above.');
}
    // Expose to window
    window.showScreen = showScreen;
    window.createNewSession = createNewSession;
    window.resumeSession = resumeSession;
    window.proceedToEEGInfo = proceedToEEGInfo;
    window.proceedToConsent = proceedToConsent;
    window.openConsent = openConsent;
    window.markConsentDone = markConsentDone;
    window.declineVideo = declineVideo;
    window.proceedToTasks = proceedToTasks;
    window.continueToCurrentTask = continueToCurrentTask;
    window.pauseStudy = pauseStudy;
    window.resumeStudy = resumeStudy;
      window.saveAndExit = saveAndExit;
      window.copyCode = copyCode;
      window.copyRecoveryLink = copyRecoveryLink;
      window.copyASLCTCode = copyASLCTCode;
    window.tryMailto = tryMailto;
    window.copyEmail = copyEmail;
    window.closeEEGModal = closeEEGModal;
    window.completeTask = completeTask;
    window.skipTask = skipTask;
    window.openEmbedInNewTab = openEmbedInNewTab;
    window.reloadEmbed = reloadEmbed;
    // Video upload functions
    window.retryVideoUpload = retryVideoUpload;
    window.continueWithoutUpload = continueWithoutUpload;
     window.debugVideoUpload = debugVideoUpload;
    window.submitASLCTIssue = submitASLCTIssue;
    window.markComplete = markComplete;
    window.scheduleEEG = scheduleEEG;
    window.expressEEGInterest = expressEEGInterest;
    window.markEEGScheduled = markEEGScheduled;
    window.showSkipDialog = showSkipDialog;
    window.skipTaskProceed = skipTaskProceed;
    window.openSupportEmail = openSupportEmail;

  </script>
</body>
</html>
